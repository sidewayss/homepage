<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Sideways S</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#ff7700">
    <meta name="apple-mobile-web-app-title" content="Sideways S">
    <meta name="application-name" content="Sideways S">
    <meta name="msapplication-TileColor" content="#603cba">
    <style>
        @font-face {
            font-family: "White Rabbit";
            src: url("SMAWS/fonts/WhiteRabbit.ttf") format("truetype"),
                 url("SMAWS/fonts/WhiteRabbit.eot") format("eot");
        }
        @font-face {
            font-family: "DejaVuSans";
            src: url("SMAWS/fonts/DejaVuSans.ttf") format("truetype");
        }

        .none {
            opacity: 0;
            pointer-events: visible;
        }

        body {
            margin: 0;
            display: flex;
            flex-flow: column nowrap;
            align-items: center;
            overflow: hidden;
            background: black;
        }
        main {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-flow: column nowrap;
            justify-content: flex-end;
            align-items: center;
        }
        #terms {
            width: 95.133%;
            flex: 0 0 auto;
            font-size: 1.25em;
            opacity: 0;
            left: -9999px;
        }

        svg {
            cursor: default;
            pointer-events: none;
        }
        text {
            font-family: "White Rabbit";
            font-size: 32px;
            white-space: pre;
            fill: #00FF00;
            filter: url(#glow);
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }
        filter {
            color-interpolation-filters: sRGB;
        }

        #logo {
            text-anchor: middle;
        }
        .rainbow {
            fill: url(#rainbow);
        }
        .song {
            font-size: 31.2px;
        }
        .spelunk {
            filter: url(#spelunk-glo);
        }
        .row {
            display: flex;
            flex-flow: row nowrap;
            justify-content: space-between;
            align-items: center;
            margin-top: 7px;
        }

        p {
            margin: 0;
            padding: 0;
            color: #AAAAAA;
        }
        p.agree {
            line-height: 1em;
            padding-left: 1em;
            text-indent: -1em;
            margin-bottom: 4px;
        }

        a { pointer-events: visible; }
        a.a { /* for #terms link to censored url - uncensored site only */
            color: #00BB00;
            outline: 0;
            text-decoration: none;
            border-bottom: 1px solid #00BB00;
        }
        a.a:hover {
            color: #00DD00;
            border-bottom: 1px dotted #00DD00;
        }
        a.a:focus {
            color: #00DD00;
            border: 1px dotted #00DD00;
            margin: -1px
        }
        a.a:active {
            color: #00DD00;
            border: 1px solid #00DD00;
            margin: -1px
        }
    </style>
<!--|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||-->
<script>
// Lint settings
/* jshint esversion: 6 */
/* jshint strict: global */
/* jshint -W014 */
/* jshint -W069 */
/* jshint -W117 */
/* jshint -W138 */
"use strict"; // @disable-check M127
const perfNow = performance.now();
console.log("perf: " + ('00000'+ Math.round(perfNow)).slice(-5));
function logNow(caption) {
    console.log(caption + ": "
             + ('00000'+ Math.round(performance.now() - perfNow)).slice(-5));
}
//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||||||||||| Global Constants |||||||||||||||||||||||
//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
const C = {                          // CSS4 named colors as rgb and hsl arrays
    aliceblue            : { rgb:[240,248,255], hsl:[208,100, 97] },
    antiquewhite         : { rgb:[250,235,215], hsl:[ 34, 78, 91] },
    aqua                 : { rgb:[  0,255,255], hsl:[180,100, 50] },
    aquamarine           : { rgb:[127,255,212], hsl:[160,100, 75] },
    azure                : { rgb:[240,255,255], hsl:[180,100, 97] },
    beige                : { rgb:[245,245,220], hsl:[ 60, 56, 91] },
    bisque               : { rgb:[255,228,196], hsl:[ 33,100, 88] },
    black                : { rgb:[  0,  0,  0], hsl:[  0,  0,  0] },
    blanchedalmond       : { rgb:[255,235,205], hsl:[ 36,100, 90] },
    blue                 : { rgb:[  0,  0,255], hsl:[240,100, 50] },
    blueviolet           : { rgb:[138, 43,226], hsl:[271, 76, 53] },
    brown                : { rgb:[165, 42, 42], hsl:[  0, 41, 41] },
    burlywood            : { rgb:[222,184,135], hsl:[ 34, 57, 70] },
    cadetblue            : { rgb:[ 95,158,160], hsl:[182, 25, 50] },
    chartreuse           : { rgb:[127,255,  0], hsl:[ 90,100, 50] },
    chocolate            : { rgb:[210,105, 30], hsl:[ 25, 67, 47] },
    coral                : { rgb:[255,127, 80], hsl:[ 16,100, 66] },
    cornflowerblue       : { rgb:[100,149,237], hsl:[219, 79, 66] },
    cornsilk             : { rgb:[255,248,220], hsl:[ 48,100, 93] },
    crimson              : { rgb:[220, 20, 60], hsl:[348, 74, 47] },
    cyan                 : { rgb:[  0,255,255], hsl:[180,100, 50] },
    darkblue             : { rgb:[  0,  0,139], hsl:[240, 37, 27] },
    darkcyan             : { rgb:[  0,139,139], hsl:[180, 37, 27] },
    darkgoldenrod        : { rgb:[184,134, 11], hsl:[ 43, 55, 38] },
    darkgray             : { rgb:[169,169,169], hsl:[  0,  0, 66] },
    darkgreen            : { rgb:[  0,100,  0], hsl:[120, 24, 20] },
    darkgrey             : { rgb:[169,169,169], hsl:[  0,  0, 66] },
    darkkhaki            : { rgb:[189,183,107], hsl:[ 56, 38, 58] },
    darkmagenta          : { rgb:[139,  0,139], hsl:[300, 37, 27] },
    darkolivegreen       : { rgb:[ 85,107, 47], hsl:[ 82, 17, 30] },
    darkorange           : { rgb:[255,140,  0], hsl:[ 33,100, 50] },
    darkorchid           : { rgb:[153, 50,204], hsl:[280, 60, 50] },
    darkred              : { rgb:[139,  0,  0], hsl:[  0, 37, 27] },
    darksalmon           : { rgb:[233,150,122], hsl:[ 15, 72, 70] },
    darkseagreen         : { rgb:[143,188,143], hsl:[120, 25, 65] },
    darkslateblue        : { rgb:[ 72, 61,139], hsl:[248, 25, 39] },
    darkslategray        : { rgb:[ 47, 79, 79], hsl:[180,  8, 25] },
    darkslategrey        : { rgb:[ 47, 79, 79], hsl:[180,  8, 25] },
    darkturquoise        : { rgb:[  0,206,209], hsl:[181, 69, 41] },
    darkviolet           : { rgb:[148,  0,211], hsl:[282, 71, 41] },
    deeppink             : { rgb:[255, 20,147], hsl:[328,100, 54] },
    deepskyblue          : { rgb:[  0,191,255], hsl:[195,100, 50] },
    dimgray              : { rgb:[105,105,105], hsl:[  0,  0, 41] },
    dimgrey              : { rgb:[105,105,105], hsl:[  0,  0, 41] },
    dodgerblue           : { rgb:[ 30,144,255], hsl:[210,100, 56] },
    firebrick            : { rgb:[178, 34, 34], hsl:[  0, 48, 42] },
    floralwhite          : { rgb:[255,250,240], hsl:[ 40,100, 97] },
    forestgreen          : { rgb:[ 34,139, 34], hsl:[120, 31, 34] },
    fuchsia              : { rgb:[255,  0,255], hsl:[300,100, 50] },
    gainsboro            : { rgb:[220,220,220], hsl:[  0,  0, 86] },
    ghostwhite           : { rgb:[248,248,255], hsl:[240,100, 99] },
    gold                 : { rgb:[255,215,  0], hsl:[ 51,100, 50] },
    goldenrod            : { rgb:[218,165, 32], hsl:[ 43, 72, 49] },
    gray                 : { rgb:[128,128,128], hsl:[  0,  0, 50] },
    green                : { rgb:[  0,128,  0], hsl:[120, 34, 25] },
    greenyellow          : { rgb:[173,255, 47], hsl:[ 84,100, 59] },
    grey                 : { rgb:[128,128,128], hsl:[  0,  0, 50] },
    honeydew             : { rgb:[240,255,240], hsl:[120,100, 97] },
    hotpink              : { rgb:[255,105,180], hsl:[330,100, 71] },
    indianred            : { rgb:[205, 92, 92], hsl:[  0, 53, 58] },
    indigo               : { rgb:[ 75,  0,130], hsl:[275, 34, 25] },
    ivory                : { rgb:[255,255,240], hsl:[ 60,100, 97] },
    khaki                : { rgb:[240,230,140], hsl:[ 54, 77, 75] },
    lavender             : { rgb:[230,230,250], hsl:[240, 67, 94] },
    lavenderblush        : { rgb:[255,240,245], hsl:[340,100, 97] },
    lawngreen            : { rgb:[124,252,  0], hsl:[ 90, 98, 49] },
    lemonchiffon         : { rgb:[255,250,205], hsl:[ 54,100, 90] },
    lightblue            : { rgb:[173,216,230], hsl:[195, 53, 79] },
    lightcoral           : { rgb:[240,128,128], hsl:[  0, 79, 72] },
    lightcyan            : { rgb:[224,255,255], hsl:[180,100, 94] },
    lightgoldenrodyellow : { rgb:[250,250,210], hsl:[ 60, 80, 90] },
    lightgray            : { rgb:[211,211,211], hsl:[  0,  0, 83] },
    lightgreen           : { rgb:[144,238,144], hsl:[120, 73, 75] },
    lightgrey            : { rgb:[211,211,211], hsl:[  0,  0, 83] },
    lightpink            : { rgb:[255,182,193], hsl:[351,100, 86] },
    lightsalmon          : { rgb:[255,160,122], hsl:[ 17,100, 74] },
    lightseagreen        : { rgb:[ 32,178,170], hsl:[177, 49, 41] },
    lightskyblue         : { rgb:[135,206,250], hsl:[203, 92, 75] },
    lightslategray       : { rgb:[119,136,153], hsl:[210, 14, 53] },
    lightslategrey       : { rgb:[119,136,153], hsl:[210, 14, 53] },
    lightsteelblue       : { rgb:[176,196,222], hsl:[214, 41, 78] },
    lightyellow          : { rgb:[255,255,224], hsl:[ 60,100, 94] },
    lime                 : { rgb:[  0,255,  0], hsl:[120,100, 50] },
    limegreen            : { rgb:[ 50,205, 50], hsl:[120, 61, 50] },
    linen                : { rgb:[250,240,230], hsl:[ 30, 67, 94] },
    magenta              : { rgb:[255,  0,255], hsl:[300,100, 50] },
    maroon               : { rgb:[128,  0,  0], hsl:[  0, 34, 25] },
    mediumaquamarine     : { rgb:[102,205,170], hsl:[160, 51, 60] },
    mediumblue           : { rgb:[  0,  0,205], hsl:[240, 67, 40] },
    mediumorchid         : { rgb:[186, 85,211], hsl:[288, 59, 58] },
    mediumpurple         : { rgb:[147,112,219], hsl:[260, 60, 65] },
    mediumseagreen       : { rgb:[ 60,179,113], hsl:[147, 44, 47] },
    mediumslateblue      : { rgb:[123,104,238], hsl:[249, 80, 67] },
    mediumspringgreen    : { rgb:[  0,250,154], hsl:[157, 96, 49] },
    mediumturquoise      : { rgb:[ 72,209,204], hsl:[178, 60, 55] },
    mediumvioletred      : { rgb:[199, 21,133], hsl:[322, 61, 43] },
    midnightblue         : { rgb:[ 25, 25,112], hsl:[240, 23, 27] },
    mintcream            : { rgb:[245,255,250], hsl:[150,100, 98] },
    mistyrose            : { rgb:[255,228,225], hsl:[  6,100, 94] },
    moccasin             : { rgb:[255,228,181], hsl:[ 38,100, 85] },
    navajowhite          : { rgb:[255,222,173], hsl:[ 36,100, 84] },
    navy                 : { rgb:[  0,  0,128], hsl:[240, 34, 25] },
    oldlace              : { rgb:[253,245,230], hsl:[ 39, 85, 95] },
    olive                : { rgb:[128,128,  0], hsl:[ 60, 34, 25] },
    olivedrab            : { rgb:[107,142, 35], hsl:[ 80, 32, 35] },
    orange               : { rgb:[255,165,  0], hsl:[ 39,100, 50] },
    orangered            : { rgb:[255, 69,  0], hsl:[ 16,100, 50] },
    orchid               : { rgb:[218,112,214], hsl:[302, 59, 65] },
    palegoldenrod        : { rgb:[238,232,170], hsl:[ 55, 67, 80] },
    palegreen            : { rgb:[152,251,152], hsl:[120, 93, 79] },
    paleturquoise        : { rgb:[175,238,238], hsl:[180, 65, 81] },
    palevioletred        : { rgb:[219,112,147], hsl:[340, 60, 65] },
    papayawhip           : { rgb:[255,239,213], hsl:[ 37,100, 92] },
    peachpuff            : { rgb:[255,218,185], hsl:[ 28,100, 86] },
    peru                 : { rgb:[205,133, 63], hsl:[ 30, 59, 53] },
    pink                 : { rgb:[255,192,203], hsl:[350,100, 88] },
    plum                 : { rgb:[221,160,221], hsl:[300, 47, 75] },
    powderblue           : { rgb:[176,224,230], hsl:[187, 52, 80] },
    purple               : { rgb:[128,  0,128], hsl:[300, 34, 25] },
    rebeccapurple        : { rgb:[102, 51,153], hsl:[270, 33, 40] },
    red                  : { rgb:[255,  0,  0], hsl:[  0,100, 50] },
    rosybrown            : { rgb:[188,143,143], hsl:[  0, 25, 65] },
    royalblue            : { rgb:[ 65,105,225], hsl:[225, 73, 57] },
    saddlebrown          : { rgb:[139, 69, 19], hsl:[ 25, 34, 31] },
    salmon               : { rgb:[250,128,114], hsl:[  6, 93, 71] },
    sandybrown           : { rgb:[244,164, 96], hsl:[ 28, 87, 67] },
    seagreen             : { rgb:[ 46,139, 87], hsl:[146, 29, 36] },
    seashell             : { rgb:[255,245,238], hsl:[ 25,100, 97] },
    sienna               : { rgb:[160, 82, 45], hsl:[ 19, 38, 40] },
    silver               : { rgb:[192,192,192], hsl:[  0,  0, 75] },
    skyblue              : { rgb:[135,206,235], hsl:[197, 71, 73] },
    slateblue            : { rgb:[106, 90,205], hsl:[248, 53, 58] },
    slategray            : { rgb:[112,128,144], hsl:[210, 13, 50] },
    slategrey            : { rgb:[112,128,144], hsl:[210, 13, 50] },
    snow                 : { rgb:[255,250,250], hsl:[  0,100, 99] },
    springgreen          : { rgb:[  0,255,127], hsl:[150,100, 50] },
    steelblue            : { rgb:[ 70,130,180], hsl:[207, 42, 49] },
    tan                  : { rgb:[210,180,140], hsl:[ 34, 44, 69] },
    teal                 : { rgb:[  0,128,128], hsl:[180, 34, 25] },
    thistle              : { rgb:[216,191,216], hsl:[300, 24, 80] },
    tomato               : { rgb:[255, 99, 71], hsl:[  9,100, 64] },
    turquoise            : { rgb:[ 64,224,208], hsl:[174, 72, 56] },
    violet               : { rgb:[238,130,238], hsl:[300, 76, 72] },
    wheat                : { rgb:[245,222,179], hsl:[ 39, 77, 83] },
    white                : { rgb:[255,255,255], hsl:[  0,  0,100] },
    whitesmoke           : { rgb:[245,245,245], hsl:[  0,  0, 96] },
    yellow               : { rgb:[255,255,  0], hsl:[ 60,100, 50] },
    yellowgreen          : { rgb:[154,205, 50], hsl:[ 80, 61, 50] }
};
const E  = {                         // E for Easy and psuedo-enums
     wsp:/[\s]+/,         sp:" ",    x:0,  R:0,  H:0,  let:0,  arrived:0,
   comsp:/[,\s]+/,     comma:",",    y:1,  G:1,  S:1,  set:1,  return :1,
    dash:/\-/g,         hash:"#",    w:2,  B:2,  L:2,  net:2,  pausing:2,
    func:/[\(\)]/,        lp:"(",    h:3,  A:3,        in :0,  mid    :3,
   gfunc:/t\(/,           rp:")",                      out:1,  outward:4,
 sepfunc:/[,\s\(\)]+/,   num:/-?[\d\.]+/g,       increment:2,  waiting:5
};
                                   //// These consts are populated by class Ez
const A  = Object.create(null);      // attribute names
const AT = Object.create(null);      // class Attr instances
const F  = Object.create(null);      // function names
const FN = Object.create(null);      // class Func instances
const U  = Object.create(null);      // units strings, e.g. "px", "deg"
//////////////////////////////////////////////////////////////////////////////
class Is {                           // helpful boolean functions wrapped-up
    static A(v)      { return Array.isArray(v);          }
    static A2(a)     { return a.some(v => Is.A(v));      }
    static N(v)      { return typeof v == "number";      }
    static String(v) { return typeof v == "string";      }
    static def(v)    { return v !== undefined;           }
    static oneElm(v) { return v.tagName || Is.String(v); }
}
//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||||||||||| Attr classes |||||||||||||||||||||||||||
//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
class Func {                         // Func: CSS or SVG function ||||||||||||||
    constructor(name, units) {
        this.name = name;
        switch (name) {              // count property == function arg count
      //case F.calc: case F.lg: case F.rg: case F.rlg: case F.rrg:
      //    this.count = -2;         // CSS gradients have a flexible structure
      //    break;
        case F.hsl: case F.hsla:
            this.hsl   = true;       /* falls through */ // fall-through
        case F.rgb: case F.rgba:
            this.color = true;
            this.count = this.name.length;
            break;
        case F.t:   case F.s:   case F.skew:
            this.count =  2;
            break;
        case F.r:   case F.s3:  case F.t3:
            this.count =  3;
            break;
        case F.cb:  case F.r3:
            this.count =  4;
            break;
        case F.m:
            this.count =  6;
            break;
        case F.m3:
            this.count = 16;         /* falls through */ // fall-through
        default:                     // .count used as a boolean: array or not?
        }                            // unitz = variable, units = getter/setter
        this.constructor.setUnits(this, units);
        this.separator = (name == F.calc ? E.sp : E.comma);
        this.plug      = (name == F.s ||
                          name == F.s3   ? "1"  : "0") + units;
        if (E.gfunc.test(this.name))
            this.isGradient = true;
        Object.seal(this);
    }
    /////////////////////////////////// apply()
    apply(v) { return this.name + E.lp + v + E.rp; }
    /////////////////////////////////// units is public, unitz is "private"
    get units()  { return this.unitz; }
    set units(u) { this.constructor.setUnits(this, u); }
    static setUnits(f, u) {          // kludgy to call setter from contructor
        if (f === FN.r3)             // units arrays are a necessary hassle
            f.unitz = ["", "", "", u];
        else if (f.hsl)              // hsla is funky, I fix alpha as percent
            f.unitz = [u, U.pct, U.pct, U.pct];
        else
            f.unitz = u;
    }
    /////////////////////////////////// hex and named colors require conversion
    fromColor(v, u = this.units) {   // fromColor() converts hex or named color
        if (!this.color) return v;   // to array of numeric args for this func.

        let n, pct;                  // rgb units "" or %, hsl units "" or angle
        pct = (u == U.pct);          // percent units require conversion
        if (v.charAt(0) == E.hash) {
            let bRR, d, rx;          // convert hex RGB, RGBA, RRGGBB, RRGGBBAA
            v   = v.substring(1);    // to an array of 3 or 4 numeric arguments.
            bRR = v.length > 4;      // bRR = RR versus R, 6 or 8 versus 3 or 4
            rx  = new RegExp(`.{${bRR + 1}}`, "g");
            d   = pct ? 2.55 : 1;
            n   = v.match(rx).map(s => parseInt(bRR ? s : s + s, 16) / d);
            if (this.count == 4 && n.length == 4 && !pct)
                n[3] /= 255;         // alpha value is 0 to 1, not 0 to 255
            if (this.hsl)
                n = this.constructor.toHSL(n, pct);
        }
        else if (C[v])               // color name
            n = this.hsl ? C[v].hsl : C[v].rgb;

        if (n && n.length < this.count)
            n.push(pct ? 100 : 1);   // assumes only the alpha value is missing,
                                     // otherwise it's not a legit color value.
        return n || v;
    }
    static toHSL(n, pct) {           // helps fromColor(). n is an array of 3 or
        let diff, hsl, max, min, rgb;// 4 numbers. pct is a boolean: isPercent.
        const R = 0, G = 1, B = 2, A = 3, H = 0, S = 1, L = 2;
        rgb  = n.slice(0, 3).map(v => v / (pct ? 100 : 255));
        max  = Math.max(...rgb);
        min  = Math.min(...rgb);
        diff = max - min;
        sum  = max + min;
        hsl  = new Array(n.length);
        if (v.length > A)
            hsl[A] = n[A];
        hsl[L] = (sum / 2) * 100;    // saturation and lightness are percents
        if (diff) {
            hsl[S] = diff / (hsl[2] < 50 ? sum : 2 - sum) * 100;
            switch(max) {
            case rgb[R]:
                n =  (rgb[G] - rgb[B]) / diff;
                break;
            case rgb[1]:
                n = ((rgb[B] - rgb[R]) / diff) + 2;
                break;
            case rgb[2]:
                n = ((rgb[R] - rgb[G]) / diff) + 4;
                break;
            }
            hsl[H] = n * 60;         // hue defaults to degrees, but other units
            if (u && u != U.deg)     // are allowed. how often are they used??
                hsl[H] *= EZ[u];     // the tradeoff = only % allowed for alpha
        }
        else {
            hsl[H] = 0;
            hsl[S] = 0;
        }
        return hsl;
    }
}           /////////////////////////// end class Func |||||||||||||||||||||||||
///////////////////////////////////////|||||||||||||||||||||||||||||||||||||||||
class Attr {                         // Attr: SVG attribute or CSS property ||||
    constructor(name, units, func) {
        this.name = name;
        this.func = func;
        if (units === false) {       // false means SVG attribute
            this.svg   = true;
            this.units = "";
            if (name == A.d || name == A.p) // d and points are unstructured
                this.isDPoints = true;      // <text>/<tspan> x, y, dx, dy, and
        }                                   // rotate are optional unstructured
        else {
            this.units = units;
            const rx   = /[A-Z]/g;   // CSS names != JavaScript names :(
            let x = rx.exec(name);   // only this.cut() requires cssName, but
            if (x) {                 // it might be useful elsewhere...
                let s = "";          // the property is only defined as needed
                let i = 0;
                let z;
                while (x) {
                    s += (name.substring(i, x.index) + "-"
                        + name.charAt(x.index).toLowerCase());
                    i = x.index + 1;
                    z = name.substring(i);
                    x = rx.exec(name);
                }
                this.cssName = s + z;
            }
        }
        if (name == A.t)             // these last ifs are so that I can seal it
            this.isTransform = true; // a mild performance hit for a clean const
        if (name == A.sc)
            this.svg = true;
        if (name == A.w || name == A.h)
            this.svg1 = true;        // SVG1 cannot style these, SVG2 can.
        Object.seal(this);
    }
    /////////////////////////////////// count() separator() plug() units() /////
    count(f = this.func) {          //\ count() returns argument count
        if (f && !Is.A(f) && !(f === FN.r && this === AT.tCSS))
            return f.count;          // if (count < 2) return undefined
        else {
            switch (this) {
          //case AT.d: AT.points:
          //    return -1;           // d and points have a flexible structure
            case AT.bF:
                return  2;
            case AT.tO:
                return  3;
            case AT.vB: case AT.m: case AT.p:
                return  4;
            case AT.values:
                return 20;
            default:      }
        }
    }                               //\ separator() plug() for value lists only
    separator(f = this.func) {       // only font-family uses commas
        if (f)                       // to set font-family with multiple values
            return f.separator;      // you must use set() with 1 string value.
        return E.sp;                 // AT.fF.let() is an unlikely requirement.
    }
    plug(f = this.func) {           //\ plug() is the default sub-value
        if (f)
            return f.plug;
        return "0" + this.units;     //??any other plug defaults??
    }
    unitz(f = this.func) {          //\ unitz() is because getters have no args
        if (f) {
            if (f.units)
                return f.units;
            else if (this === AT.tCSS) {
                switch (f) {
                case FN.t:           // fallback if no value specified
                    return U.px;
                case FN.r:           // CSS FN.r == FN.rZ
                    return U.deg;
                }
            }
        }
        return this.units;
    }

    get izAll() {                   //\ does attr spread 1 value to all subs?
        return(this === AT.bF);      // for now baseFrequency is the only one
    }
    izSVG(elm) { return this.svg || this.svg1 && elm instanceof SVGElement; }
    /////////////////////////////////// Remove Function: renamed to "cut" //////
    cut(elms) {
        elms = this.constructor.elmArray(elms);
        elms.forEach((elm) => {
            if (this.izSVG(elm))
                elm.removeAttribute(this.name);
            else
                elm.style.removeProperty(this.cssName || this.name);
        });
    }
    /////////////////////////////////// Get Functions: get() getn() getu() /////
    get(elms) {             //////////\ get() returns the raw string values
        let b = Is.oneElm(elms);    //\ if elms is any kind of collection, it
        elms  = this.constructor.elmArray(elms);
        if (!b) {                   //\ returns an array, even if length == 1.
            let l = elms.length;    //\ normalizes CSS/SVG and converts null to
            let s = new Array(l);   //\ "", see zget().
            for (let i = 0; i < l; i++)
                s[i] = this.constructor.zget(this, elms[i]);
            return s;
        }
        else    return this.constructor.zget(this, elms[0]);
    }
    static zget(t, elm) {           //\ zget() gets a single element's value
        let s;
        if (t.svg)
            s = elm.getAttribute(t.name);
        else {
            s = elm.style[t.name];   // two possible fallbacks: svg value or...
            if (!s & elm instanceof SVGElement)
                s = elm.getAttribute(t.name);
            if (!s)                  // ...css value within document's <style>.
                s = getComputedStyle(elm)[t.name];
        }
        return s ? s.trim() : "";    // trim is safe, "" is friendlier than null
    }                       ////////////////////////////////////////////////////
    getn(elms, f, u) {      //////////\ getn() converts values to numbers
        let v = this.get(elms);
        return Is.A(v) ? this.za(v, f, u) : this.zn(v, f, u);
    }
    za(arr, f, u) {                 //\ za() converts an array of elms' values
        let l = arr.length;         //\ za(), zn(), and zparse() are called by
        let v = new Array(l);       //\ new Easer() too.
        for (let i = 0; i < l; i++)
            v[i] = this.zn(arr[i], f, u);
        return v;
    }
    zn(s, f, u = this.unitz(f)) {   //\ zn() converts 1 element's value(s)
        s = this.zparse(s, f);
        return Is.A(s) ? s.map(v => Attr.toNumber(v, f, u))
                       : Attr.toNumber(s, f, u);
    }
    zparse(s, f = this.func) {      //\ zparse() parses one element's value
        let v = "";
        let i = s.indexOf(E.lp);
        while (i >= 0) {             // if (function) get the arguments
            v += s.substring(++i, s.indexOf(E.rp, i)) + E.sp;
            i  = s.indexOf(E.lp, i); // if (>1 function) separate with E.sp
        }
        v = (v ? v.trim() : s);
        v = v.split(E.comsp);
                                     // if (value list) always return an array
        return v.length > 1 || this.count(f) ? v : v[0];
    }                       ////////////////////////////////////////////////////
    getu(elms, f = this.func) { //////\ getu() is for unstructured attrs/funcs
        let i, l, o, seps, vals, x; //\ it is designed to help new Geaser()
        elms = this.constructor.elmArray(elms);
        l = elms.length;            //\ it returns an object with 5 properties
        x = this.get(elms);          // elms and x are always arrays
        o = Object.create(null);     // returned object has 3 array properties
        o.vals = new Array(l);       // numeric values as strings
        o.seps = new Array(l);       // string leftovers as separators
        o.nums = new Array(l);       // numeric values as numbers
        for (i = 0; i < l; i++) {    // pre-process hex and named colors
            if (x[i] && f && f.color) {
                vals = x[i].split(E.sepfunc);
                seps = x[i].match(E.sepfunc);
                x[i] = "";
                if (seps.length < vals.length)
                    seps.push("");   // simplifies the loop
                vals.forEach((v, i) => {
                    v = f.fromColor(v);
                    if (isA(v))      // named colors limit the use of RegExp
                        vals[i] = f.apply(v.join(f.separator));
                    x[i] += vals[i] + seps[i];
                });
            }                         // create the return values
            o.vals[i] = x[i].match(E.num) || [""];
            o.seps[i] = x[i].split(E.num);
            o.nums[i] = o.vals[i].map(this.constructor.toNumber);
        }                            // does it begin and/or end with a number?
        o.numBeg = new RegExp("^" + E.num.source).test(x[0]);
        o.numEnd = new RegExp(E.num.source + "$").test(x[0]);
        return o;                    // if (>1 element) value formats must align
    }
    /////////////////////////////////// Set Functions: set() let() vet() net()
    set(elms, v, f, u) {    //////////\ set() overrides everything
        let b, c, i;
        elms = this.constructor.elmArray(elms);
        c    = this.count(f);
        b    = this.constructor.dims(v) == (c ?  2 : 1);
        for (i = 0; i < elms.length; i++)
           this.constructor.set(this, elms[i], this.zet(b ? v[i] : v, f, u, c));
    }
                            //////////\ let(), vet(), net() set sub-values only
    let(elms, v, m, f, u) { //////////\ let() is for structured value/arg lists
        let b, b0, bf, bi, c, fs, i, j, k, l, mf, p, s, tc, tf, tp, vf, x, z;
        tc   = this.constructor;
        elms = tc.elmArray(elms);
        if (Is.A(f))                 // multi-func transforms eat up a lot of
            bf = true;               // code: multi-existing and/or multi-user
        else {
            m  = tc.svgRot(this.svg, f, m, 1, v);
            c  = this.count(f);      // if (c == 0) it's a multi-func transform
            f  = f ? [f] : [];       // or you should call set() instead.
            b0 = f.length < 1;       // user array of 1 func is not valid
            bi = tc.izByElm(v, c);
        }
        z = v;
        x = this.get(elms);          // x = existing values
        for (i = 0; i < x.length; i++) {
            if (bi) z = v[i];        // values by element for 1 or 0 funcs

            if (x[i]) {
                p = x[i];            // p = plug, which is preset to full x[i]
                if (p.includes(E.lp)) {
                    b = !b0 && f[0] !== FN[p[0]];
                    p = p.split(E.func);
                    if (p.length % 2)// trim trailing empty element
                        p.length--;
                    if (this.isTransform && (p.length > 2 || bf || b)) {
                        l  = p.length / 2;
                        fs = new Set();
                        tf = new Array(l);
                        tp = new Array(l);
                        for (j = 0, k = 0; j < l; j++) {
                            tf[j] = p[k++].trim();
                            tp[j] = p[k++].trim();
                            fs.add(FN[tf[j]]);
                        }            // existing func order overrides user order
                        f.forEach((func) => { fs.add(func); });
                        s  = "";
                        Array.from(fs).forEach((func, fi) => {
                            j = f.indexOf(func);
                            if (j >= 0) {
                                c = this.count(func);
                                if (bf) {
                                    vf = tc.ztf(v, func, j);
                                    mf = tc.ztf(m, func, j);
                                    mf = tc.svgRot(this.svg, func, mf, vf);
                                    z  = tc.izByElm(v, c) ? vf[i] : vf;
                                }
                                s += this.zet(z, func, u, c, m, tp[fi]) + E.sp;
                            }
                            else
                                s += FN[tf[fi]].apply(tp[fi]) + E.sp;
                        });
                        tc.set(this, elms[i], s.trimEnd());
                        continue;    // already called set(), leapfrog to next
                    }
                    else {           // only transforms accept >1 func
                        if (b0)      // if only one existing func, f is optional
                            f = [FN[p[0]]];
                        p = p[1];
                    }
                }
                tc.set(this, elms[i], this.zet(z, f[0], u, c, m, p));
            }
            else                     // !x[i] = fall back to this.set()
                this.set(elms[i], z, f[0], u);
        }
    }                               //\ zet() helps instance.set() and .let()
    zet(v, f = this.func, u = this.unitz(f), c = this.count(f), m, p) {
        if (c) {                     // list of values
            let isAv = Is.A(v);
            let isAu = Is.A(u);      // hsl(), hsla(), and rotate3d() mix units
            if (m || (isAv && (v.length < c || v.includes(undefined)))) {
                let i, isAp, z;      // the array needs plugging
                if (Is.def(p)) {
                    p = p.trim().split(E.comsp);
                    while (p.length < c)
                        p.push(this.plug(f));
                }
                else
                    p = this.plug(f);

                isAp = Is.A(p);      // let() uses p[]
                z    = new Array(c); // array of new values
                if (m) {             // mask is bitmask
                    let j, k;
                    if (!isAv)
                        v = [v];
                    for (i = 0, j = 1, k = 0; i < c; i++, j *= 2)
                        z[i] = m & j
                             ? v[k++] + (isAu ? u[i] : u) : (isAp ? p[i] : p);
                }
                else {               // mask is array with empty elements
                    for (i = 0; i < c; i++)
                        z[i] = Is.def(v[i])
                             ? v[i]   + (isAu ? u[i] : u) : (isAp ? p[i] : p);
                }
                v = z.join(this.separator(f));
            }
            else if (isAv) {         // the array is fully specified
                if (u)
                    v.forEach((n, i, a) => { a[i] = n + (isAu ? u[i] : u); });
                v = v.join(this.separator(f));
            }
        }
        else    v += u;              // single value

        if (f) return f.apply(v);
        else   return v;
    }                                // izByElm() helps let()
    static izByElm(v, c) { return Attr.dims(v) == (c ? 2 : 1); }
                            //////////\ vet(), net() are for unstructured values
    vet(elms, v, m) {               //\ vet() "values" include function names
        this.zvnet(false, elms, v, m);
    }
    net(elms, v, m, f = this.func) {//\ net() replaces only numbers
        this.zvnet(true,  elms, v, m, f);
    }
    zvnet(isN, elms, v, m, f) {     //\ zvnet() consolidates vet() and net()
        let av, i, j, l, seps, vals, x;
        elms = this.constructor.elmArray(elms);
        x    = isN ? this.getu(elms, f) : this.get(elms);
        if (!Is.A(x)) x = [x];       // x = existing values
        if (!Is.A(m)) m = [m];       // m = mask = array of indices into x[elm]
        if (!Is.A(v)) v = [v];
        else if (Is.A(v[0]))
            b2 = true;               // v is a 2D array
        for (i = 0; i < x.length; i++) {
            if ((isN && x.vals[i][0]) || (!isN && x[i])) {
                vals = isN ? x.vals[i] : x[i].split(E.sepfunc);
                seps = isN ? x.seps[i] : x[i].match(E.sepfunc);
                for (j = 0; j < m.length; j++)
                    vals[m[j]] = b2 ? v[i][j] : v[j];
                av = "";             // av = attribute value, rebuild it
                l  = vals.length;    // vals can be different lengths, so long
                if (seps.length < l) // as the minimum length > m[m.length - 1].
                    seps.push("");   // simplifies the next loop
                for (i = 0; i < l; i++)
                    av += vals[i] + seps[i];
                this.constructor.set(this, elms[i], av);
            }                        // if no existing value, no way to plug it
        }
    }
    /////////////////////////////////// public static methods //////////////////
    static set(attr, elm, v) {       // Attr.set() handles CSS versus SVG
        if (attr.izSVG(elm))
            elm.setAttribute(attr.name, v);
        else
            elm.style[attr.name] = v;
    }
    static visible(elms, b) {        // much nicer as a boolean
        Attr.set(AT.visibility, elms, b ? "visible" : "hidden");
    }
    static colorFunc(f) {            // changes color function globally
        for (let i of Attr._colors())
            AT[i].func = f;
    }
    static lengthUnits(u) {          // changes <length> units globally
        let i;
        for (i of Attr._cssL())
            AT[i].units = u;
        for (i of Attr._cssL2())
            AT[i].units = u;
        for (i of Attr._funcL())
            FN[i].units = u;
    }
    static angleUnits(u) {           // changes <angle>  units globally
        for (let i of Attr._funcA())
            FN[i].units = u;
    }
    /////////////////////////////////// "friend class" static methods //////////
    static dims(v) {                //\ dims() counts array dimensions up to 2
        return(Is.def(v) ? (Is.A(v) ? (Is.A2(v) ? 2 : 1) : 0) : -1);
    }                                // if (!Is.def(v))  return -1;
    static elmArray(elms, doc = document) {
        if (elms) {                 //\ elmArray() returns an array of elements
            if (!Is.A(elms)) {      //\ user flexibility + internal consistency
                if (Is.oneElm(elms)) // if it's not class Array, convert it now:
                    elms = [elms];                    //- Element, String
                else if (elms.size)
                    elms = Array.from(elms.values()); //- Map, Set
                else if (elms.length)
                    elms = Array.from(elms);          //- HTMLCollection, NodeList
                else
                    elms = Object.values(elms);       //- Object
            }
            elms.forEach((v, i, a) => {
                if (Is.String(v))    // convert Strings to Elements, by id
                    a[i] = doc.getElementById(v);
            });
        }
        return elms;
    }
    static svgRot(b, func, m, l, f, a, p) {
        b &= (func === FN.r);       //\ svgRot() handles SVG rotate's quirks
        if (!m) {                   //\ and if (!b) zap() helps Teaser
            m = Attr.zap(0, f, a, p);
            if (b && (!m || Attr.dims(m) < Math.min(l, 2)))
                m = EZ.x;            // special lazy syntax: angle-only
        }
        else if (b) {                // else alternate arg order: (angle, x, y)
            if (m & EZ.y)     m += EZ.y;
            if (m & EZ.x)     m += EZ.x;
            if (m & EZ.angle) m -= EZ.angle - 1;
        }
        return m;
    }
    static toNumber(v, f, u) {      //\ toNumber() is soft numeric conversion
        let n = parseFloat(v);      //\ if it fails to convert, you must revert
        return Number.isNaN(n) ? (f ? f.fromColor(v, u) : v) : n;
    }
    static toBools(v, l) {          //\ toBools() returns 2 arrays of array
        let o = Object.create(null);//\ indices for an addend/plug: true/false
        if (v) {
            let f, i, j, t;
            t = [];                  // t for true, f for false
            f = [];
            if (Is.A(v)) {           // v is an array with empty slots
                for (i = 0; i < l; i++)
                    (Is.def(v[i]) ? t : f).push(i);
            }
            else {                   // v is a bitmask
                if (!l) l = Math.floor(Math.log2(v)) + 1;
                for (i = 0, j = 1; i < l; i++, j *= 2)
                    (v & j       ? t : f).push(i);
            }
            o.true  = t;
            o.false = f;
        }
        else if (l) {
            o.true  = Array.from({length:l}, (_, i) => i);
            o.false = [];
        }
        return o;
    }                               //\ Attr.toBools(Ez.zap(...), length);
    static zap(mask, factor, addend, plug) {
        return mask || Attr.zv(factor) || Attr.zv(addend) || Attr.zv(plug);
    }
    static zv(v) { return Is.A(v) ? v : false; }
                                    //\ ztf() called by let() and new Teaser()
    static ztf(v, f, i) {           //\ parses multi-func transform user values
        if (!v || Is.N(v) || Is.String(v)) return v;  //- number or string
        if (Is.def(v.length))       return v[i];      //- array or "array-like"
        if (Is.def(v.get))          return v.get(f);  //- map or set
        if (f && Is.def(v[f.name])) return v[f.name]; //- object w/string keys
    }
    /////////////////////////////////// javascript does not have class variables
    static _colors() {
        return ["fill","stroke","stop-color","color","backgroundColor",
                "borderTopColor", "borderBottomColor","borderColor",
                "borderLeftColor","borderRightColor"];
    }
    static _svg() {
        return ["x","y","x1","x2","y1","y2","r","cx","cy","d","dx","dy",
                "stop-opacity","xlink:href","preserveAspectRatio","viewBox",
                "azimuth","baseFrequency","elevation","k1","k2","k3","values",
                "stdDeviation","data-idx"];
    }
    static _css() {                  // <number> or <string>, no default units
        return ["display","opacity","pointerEvents",
                "flexFlow","justifyContent","alignItems","alignSelf",
                "fontFamily","fontWeight","fontStyle","fontStretch",
                "overflowX","overflowY",
                "transform","transformOrigin"];
    }
    static _cssL() {                 // <length> or <percent> data type
        return ["height","width","stroke-width","fontSize",
                "border","margin","padding","left","right","bottom",
                "borderTop", "borderBottom", "borderLeft", "borderRight",
                "marginTop", "marginBottom", "marginLeft", "marginRight",
                "paddingTop","paddingBottom","paddingLeft","paddingRight"];
    }
    static _svg2() {                 // 2 = attribute names with no abbreviation
        return ["class","offset","points","seed","type"];
    }
    static _css2() {
        return ["background","cursor","filter","flex","mask","overflow",
                "position","visibility"];
    }
    static _cssL2() {
        return ["top"];
    }
    static _funcs() {                // functions: first 4 are the color funcs
        return ["rgb","rgba","hsl","hsla","url","attr","var","calc",
                "repeating-linear-gradient","repeating-radial-gradient",
                          "linear-gradient",          "radial-gradient",
                "matrix",  "rotate",   "scale",  "translate","cubic-bezier",
                "matrix3d","rotate3d", "scale3d","skew"];
    }
    static _funcL() {                // functions that take <length> arguments
        return ["perspective", "translate3d"];
    }
    static _funcA() {                // functions that take <angle> arguments
        return ["rotateX","rotateY","rotateZ"];
    }
    static _func2() {
        return ["skewX","skewY"];
    }
    static _lengths () {             // units "class variables"
        return ["px","em","rem","vw","vh","vmin","vmax","pt","pc","mm","in"];
    }
    static _angles() {
        return ["deg","rad","grad","turn"];
    }
}           /////////////////////////// end class Attr |||||||||||||||||||||||||
///////////////////////////////////////|||||||||||||||||||||||||||||||||||||||||
class Ez {                           // Ez: bitmask pseudo-enums for value lists
    constructor() {                  //     also fills: E, F, FN, A, and AT
        let abcd, rgba, rgbc;
        rgba = ["R","G","B","A"];    // rgb(), rgba(), hsl(), hsla(), viewBox++
        this.make(rgba);
        this.make(["H","S","L"]);
        rgbc = rgba.slice();         // <feColorMatrix type="matrix" values>
        rgbc.push("C");              // C for constant, the fifth column
        this.make(Array.from({length:20},
                             (_, i) => rgbc[i % 5] + rgba[Math.floor(i / 5)]));
        abcd = ["a","b","c","d"];    // matrix3d()
        this.make(Array.from({length:16},
                             (_, i) => abcd[i % 4] + Math.floor(i / 4 + 1)));
        abcd.push("e","f");          // SVG matrix() naming conventions
        this.make(abcd);             // matrix()
        this.tx    = this.e;         // CSS matrix() naming conventions
        this.ty    = this.f;
                                     // fill the other objects:
        this.fill(U, Attr._lengths(), 4);
        this.fill(U, Attr._angles(),  5);
        this.fill(F, Attr._funcs(),   5, FN, "");
        this.fill(F, Attr._funcL(),   5, FN, U.px );
        this.fill(F, Attr._funcA(),   5, FN, U.deg);
        this.fill(F, Attr._func2(),  99, FN, "");
        this.fill(A, Attr._colors(),  3, AT, "", FN.rgb);
        this.fill(A, Attr._svg(),     3, AT, false);
        this.fill(A, Attr._css(),     3, AT, ""   );
        this.fill(A, Attr._cssL(),    3, AT, U.px );
        this.fill(A, Attr._svg2(),   99, AT, false);
        this.fill(A, Attr._css2(),   99, AT, ""   );
        this.fill(A, Attr._cssL2(),  99, AT, U.px );
        U.pct   = "%";               // not easily automated
        AT.tCSS = AT.t;              // transform is very special
        AT.tSVG = new Attr(A.t, false);
        A .bg   = A .background;     // background shortcuts not calculatable
        AT.bg   = AT.background;     // A.b == "border"
        A .bgC  = A .backgroundColor;
        AT.bgC  = AT.backgroundColor;
        AT.sc.svg  = true;           // stop-color grouped with colors, not svg
        AT.filter.func = FN.url;
                                     // finish filling this (EZ)
        this.make([A.x, A.y, A.w, A.h]);
        this.w     = this.width;     // for convenience and consistency w/Attr
        this.h     = this.height;
        this.z     = this.w;         // for most 3D transforms
        this.angle = this.h;         // for rotate3d()
        this.rad   = Math.PI / 180;  // some non-bitmask values too
        this.grad  = 10 / 9;
        this.turn  =  1 / 360;
        Object.freeze(E);    Object.freeze(F);  Object.freeze(A);
        Object.freeze(this); Object.freeze(FN); Object.freeze(AT);
    }
    make(v) {                        // creates bitmasks for this
        for (let i = 0, j = 1; i < v.length; i++, j *= 2)
            this[v[i]] = j;
    }
    fill(o, a, l, obj, units, func) {// populates global consts: A, AT, F, FN, U
        let i, k, ln, m, s, xh;      // k = key, ln = long name, m = match
        const rx = /[A-Z]|\d|-(.)/g;
        for (s of a) {
            if (s.length < l)        // l == min length for shortening a name
                k = s;
            else {
                k = s.charAt(0);
                m = s.match(rx);     // no look-back in js regexp, so
                if (m) {             // the "-" is included in the match.
                    for (i of m)
                        k += i.charAt(i.length - 1);
                    xh = false;
                }
                else {               // xlink:href becomes href, SVG 2.0 style
                    xh = s.indexOf(":") + 1;
                    if (xh)
                        k = s.substring(xh);
                }
            }
            o[k] = s;
            if (k != s && !xh) {     // : is a legit char, but no AT.xlink:href
                ln = s.replace(E.dash, "");
                o[ln] = s;           // long name is a duplicate entry (strings)
            }
            if (obj) {               // add to objects collections: FN, AT
                if (obj === FN) obj[k] = new Func(s, units);
                else            obj[k] = new Attr(s, units, func);
                if (k != s)
                    obj[ln] = obj[k];// long name links to the original entry
            }
        }
    }
}                    ////////////////// end class Ez |||||||||||||||||||||||||||
const EZ = new Ez();                 // one instance is all you need
//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||||||||||| Easy classes |||||||||||||||||||||||||||
//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
class Easer {                        // Subject of: "The easer eases the easee."
    constructor(ee, elms,            // args after elms defined only by Teaser
                func = ee.func, u = ee.units, c = ee.count,
                values, prefix, suffix,
                f   = (Is.def(values) ? undefined : ee.factor),
                a   = (Is.def(values) ? undefined : ee.addend),
                p   = (Is.def(values) ? undefined : ee.plug),
                max = (Is.def(values) ? undefined : ee.max),
                min = (Is.def(values) ? undefined : ee.min),
                b   = (c ? Attr.toBools(Attr.zap(ee.mask, f, a, p), c) : false))
    {
        if (!elms) return;           // called from new Geaser() via super()
        let d, dims, o, xv;
        let l  = elms.length;
        let bl = elms.length > 1;
        let tc = this.constructor;   // a much shorter name, and one less lookup

        this.easee = ee;    this.elms  = elms;          this.prefix = prefix;
        this.count = c;     this.func  = func;          this.suffix = suffix;
        this.units = u;     this.bools = undefined;     this.addend = undefined;
        this.max = max;     this.plug  = undefined;     this.factor = undefined;
        this.min = min;     this.turn  = undefined;     this.number = undefined;
        this.idx = 0;   this.separator = undefined;   this.computer = undefined;
        /////////////////////////////// parse the factor, addend, and plug /////
        o    = tc.zobj(max, min, a, f, p, c, b, ee.attr.plug(func));
        dims = Array.from(o, (v) => v.dims);
        d    = Math.max(...dims);
        if (ee.attr.izAll & d < 1 && !ee.mask) {
            c = undefined;           // it's not a value list this time
            o.length--;              // trims the plug out of the array
        }
        if (!c && o.length == 3 && !Is.def(a) && o[0].value == Infinity
                                && !Is.def(p) && o[1].value ==-Infinity) {
            this.type = null;     ////\ apply raw ease().value to attribute
            this.max  = o[0].value;  // 0 = max, 1 = min, 2 = addend, 3 = factor
            this.min  = o[1].value;  // if (c) {4 = plug; if (f == 1) 3 = plug;}
            Object.seal(this);       // if (factor == 1) 3 is spliced out
            return;                  // the logic gets goofy w/o this return
        }
        if (!c) {                 ////\ single value with factor/addend/plug
            if (bl)                  // izF = izFull, like the static function
                o.forEach((v) => { v.izF = Is.A(v.value); });
                                     // if any undefined, get existing values
            if (o.some(v => tc.zundef(v)))
                xv = tc.zex(elms, ee, values, true);
                                     // this.type = true|false = array|value
            this.type = o.some(v => v.izF) || (xv && xv.length > 1) || false;
            if (this.type) {         // 1D array by element
                this.number = new Array(l);
                b = Attr.toBools(null, l);
            }                        // b.true contains 100% of the indices
            o.forEach((v) => {       // it's an off-label use of Attr.toBools()
                if (this.type) {     // it makes this call to izFull() possible
                    v.bools = b.true;
                    if (v.izF)
                        v.izF &= tc.izFull(v, 1, l);
                    this[v.key] = tc.zap(v, xv, l, 0);
                }
                else                 // xv is alway an array, if it's defined
                    this[v.key] = tc.zval(v, xv ? xv[0] : undefined);
            });
            if (Is.def(this.factor)) {
                this.factor   = tc.zReplace(ee.isEnd, this.factor, this.addend);
                this.computer = this.type ? this.computeSub : this.computeOne;
            }
            else
                this.computer = this.type ? this.addSub     : this.addOne;
        }
        else {                    ////\ value list assumes factor|addend|plug
            let be, l2;
            be = ee.byElm;           // determine dimensionality and fullness
            if (b.true.length == 1) {// single sub-value has multiple syntaxes
                let i = dims.indexOf(0);
                if (i >= 0) {
                    d = Math.max(d, 1);
                    do {             // ensure that it's an array
                        o[i].value = [o[i].value];
                        o[i].dims++;
                        i = dims.indexOf(0, i + 1);
                    } while (i >= 0);
                }
                if (d > 0 && bl) {   // 1D array for one sub-value is by elm...
                    o.forEach((v) => {
                        if (v.dims == 1 && v.value.length > 1) {
                            v.tmp   = v.value;
                            v.value = new Array(c);
                            v.value[v.bools[0]] = v.tmp;
                            v.dims++;
                            d = Math.max(d, 2);
                        }            // ...convert it to 2D by sub-value by elm.
                    });
                }
            }
            d = Math.max(d, 1);      // if (c) it's a minimum of 1
            o.forEach((v) => {
                v.izF = tc.izFull(v, d, c, l, be);
            });
            if (d == 1 && bl && o.some(v => !v.izF)) {
                d++;                 // if getting existing values for >1 elm,
                o.forEach((v) => {   // it's a two-dimensional setup.
                    if (v.izF)
                        v.izF = tc.izFull(v, d, c, l, be);
                });
            }
            l2 = (d == 2 ? l : 0);  //\ get existing values?
            if (o.some(v => !v.izF)) {
                xv = tc.zex(elms, ee, values);
                if (!l2)
                    xv = xv[0];
                if (func && func.color) {
                    let isAu = Is.A(u);
                    for (let i = 0; i < l; i++) {
                        if (xv[i] && xv[i].length == 1)
                            xv[i] = func.fromColor(xv[i][0], u)
                                        .map(n => n + (isAu ? u[i] : u));
                    }
                }
            }
            o.reverse();            //\ set this.max, min, factor, addend, plug
            o.forEach((v, i) => {    // plug must be first, pre-zReplace()
                this[v.key] = tc.zap(v, xv, c, l2, be);
                if (i == 0)          // convert xv to numbers for post-plug
                    xv = tc.zReplace(3, xv, func, ee.units);
            });
            if (Is.def(this.factor)) {
                this.factor   = tc.zReplace(ee.isEnd, this.factor, this.addend);
                this.computer = (d == 2 ? this.computeElm : this.computeSub);
            }                       //\ set everything else
            else
                this.computer = (d == 2 ? this.addElm     : this.addSub);

            this.type      = d;      // this.type = 1 or 2
            this.bools     = b;
            this.number    = tc.arrayz(c, l2);
            this.separator = ee.attr.separator(ee.func);
        }
        Object.seal(this);
    } ///////////////////////////////// end constructor() //////////////////////
    /////////////////////////////////// static helpers for Easer and Geaser ////
    static arrayz(li, lo, fill) { ////\ arrayz() creates a sized/filled array
        if (Is.def(fill))           //\ li = inner length, lo = outer length
            return(lo ? Array.from({length:lo}, () => new Array(li).fill(fill))
                      : new Array(li).fill(fill));
        else                         // the outer dimension is the optional one
            return(lo ? Array.from({length:lo}, () => new Array(li))
                      : new Array(li));
    }                             ////\ zex() gets and/or parses existing values
    static zex(elms, ee, v = ee.attr.get(elms), n) {
        return n ? ee.attr.za(v, ee.func, ee.units)
                 : v.map(s => ee.attr.zparse(s, ee.func));
    }                               //\ zobj() creates and fills the o variable
    static zobj(max, min, a, f, p, hasPlug, b, pv) {
        let o = Array.from({length:hasPlug ? 5 : 4}, () => Object.create(null));
        const key  = ["max", "min", "addend", "factor", "plug"];
        const plug = [Infinity, -Infinity, , 1, ];
        o.forEach((v, i) => {
            v.key   = key[i];
            v.plug  = plug[i];
            v.value = Easer.zReplace(2, arguments[i], v.plug);
            v.dims  = Attr.dims(v.value);
            v.bools = b ? b.true : b;
        });
        o[2].plug = Attr.toNumber(pv);
        if (hasPlug) {               // zReplace(2) = undefined for addend/plug
            o[4].plug  = pv;
            o[4].bools = b.false;    // plug is the filler, not the meat
        }
        if (o[3].value == 1)         // if no factor, remove its array element,
            o.splice(3, 1);          // which is best left until the end.
        return o;
    }
    static zundef(v) {            ////\ zundef() = v.value is or has undefined?
        return v.izF ? v.value.includes(undefined) : !Is.def(v.value);
    }
    static zap(o, xv, li, lo, byElm, g) {
        if (o.izF) return o.value;////\ zap() populates factor, addend, plug
                                    //\ g == array of indices into xv: Geaser()
        let b, bi, i, j, v;
        v = Easer.arrayz(li, lo);
        for (i = 0; i < o.bools.length; i++) {
            b  = o.bools[i];
            bi = g ? g[i] : b;
            if (lo) {
              for (j = 0; j < lo; j++)
                v[j][b] = Easer.zval(o, xv[j][bi], b, j, byElm);
            }
            else   v[b] = Easer.zval(o,    xv[bi], b);
        }
        return v;
    }
    static zval(o, xv, b, j, byElm) {
        let v;                    ////\ zval() assigns a value from the correct
        switch (o.dims) {           //\ source, or one of two fallback values.
        case -1:  v = xv;          break;
        case  0:  v = o.value;     break;
        case  1:  v = o.value[b];  break;
        case  2:  v = byElm
                    ? o.value[j][b]
                    : o.value[b][j];
        }
        if (!v && v !== 0)           // double fallback: existing value, plug
            v = (xv || xv === 0 ? xv : o.plug);
        return v;
    }
    static zReplace(b, v, z, u) { ////\ zReplace() handles three processes:
        if (!b)                      //#1. factor = end (versus distance)
            return v;                //#2. replace undefined with "no change"
        if (!Is.A(v)) {              //    and null with undefined = get values
            switch(b) {              //#3. convert existing values to numbers
            case 1:                  //#1. v = factor; z = addend.
                return !Is.def(v) || v == 1 ? v : v - z;
            case 2:                  //#2. v = factor, addend, plug, max, or min
                return  Is.def(v) ? (v === null ? undefined : v) : z;
            case 3:                  //#3. v = factor, addend, max, or min;
                return Attr.toNumber(v, z, u);
            }                        // z = Func instance; u = units.
        }
        let l = v.length;
        let a = new Array(l);        // handles arrays recursively
        for (let i = 0; i < l; i++)
            a[i] = Easer.zReplace(b, v[i], Is.A(z) ? z[i] : z);
        return a;
    }
    static izFull(o, d, li, lo, byElm) {
        let b, lb;                ////\ izFull() checks the contents of an array
        if (o.bools)                 // if (1D array by elm) bools == undefined
            lb = o.bools.length;     // if (d == 2 && dfap == 1) 1D array by
        if (o.dims == 1)             // sub-value only, by element not allowed.
            Easer.zSpread(o.value, o.bools, li);
        if (o.dims == d) {           // d == 1 or 2, never 0 or -1
            if (d == 1)
                b = Easer.zFu(o.value, lb);
            else if (byElm) {
                b = Easer.zFu(o.value, lb, lo);
                Easer.zSpread(o.value, o.bools, lo, li); }
            else {
                b = Easer.zFu(o.value, lo, lb);
                Easer.zSpread(o.value, o.bools, li, lo); }
        }
        return b;
    }
    static zFu(arr, li, lo) {       //\ zFu() helps izFull()
        let b = Is.A(arr) && arr.filter(v => Is.def(v)).length >= lo ? lo : li;
        if (b && lo) {
            for (let i of arr) {     // if (!Is.A(i)) it's filled by zSpread()
                if (Is.A(i) && arr.filter(v => Is.def(v)).length < li)
                    return false;
            }
        }
        return b;
    }
    static zSpread(arr, bools, lo, li, byElm) {
        let i;                    ////\ zSpread() preps an array for processing.
        if (byElm) {                //\ here, li is the optional 2nd dimension,
            arr.length = lo;        //\ elsewhere it's lo. confusing, but true.
            for (i = 0; i < lo; i++) {
                if (Is.A(arr[i]))
                    Easer.zSp(arr[i], bools, li);
                else
                    arr[i] = new Array(li).fill(arr[i]);
            }
        }
        else {
            if (arr.length < lo) {
                if (bools)           // 1D array by sub-value
                    Easer.zSp(arr, bools, lo, li);
                else
                    arr.length = lo; // 1D array by element
            }
            if (li) {                // 2D array, spread inner dimension
                for (i = 0; i < lo; i++) {
                    if (Is.A(arr[i]))
                        arr[i].length = li;
                    else
                        arr[i] = new Array(li).fill(arr[i]);
                }
            }
        }
    }
    static zSp(arr, bools, lo, li) {//\ zSp() helps zSpread()
        let bi, i;
        i = arr.length - 1;
        arr.length = lo;
        for (; i >= 0; i--) {
            bi = bools[i];
            if (bi > i) {
                arr[bi] = arr[i];
                arr[i]  = li ? [] : undefined;
            }
        }
    }
    /////////////////////////////////// apply() and compute() //////////////////
    apply(e) {                       // e = easeMe() return value
        let ee = this.easee;
        let ev = ee.evaluate(e);
        if (ev === false)   return;

        let v    = this.compute(ev);
        let isAv = Is.A(v);
        let attr = ee.attr;
        if (ee.easy.byElm) {
            if (Is.def(this.turn)) {
                let tv = this.compute(this.turn);
                if (Is.A(tv))
                    tv = tv[this.idx];
                Attr.set(attr, this.elms[this.idx], tv);
                ee.turn(this);
            }
            Attr.set(attr, this.elms[this.idx], isAv ? v[this.idx] : v);
        }
        else if (isAv)
            this.elms.forEach((elm, i) => {Attr.set(attr, elm, v[i]);});
        else
            this.elms.forEach((elm)    => {Attr.set(attr, elm, v);});

        if (ee.peri)
            ee.peri(this, e);
    }
    compute(ev) {
        switch (this.type) {
        case null:
            return this.vfps(this.vnu(ev));
        case false:
            return this.vfps(this.vnu(this.computer(ev)));
        case true:
            return Array.from({length:this.elms.length}, (_, i) =>
                   this.vfps(this.vnu(this.computer(ev, i), false, i), i));
        case 1:
            return this.vfps(
                   this.varr(this.count, ev, this.plug).join(this.separator));
        case 2:
            return Array.from({length:this.elms.length}, (_, i) =>
                   this.vfps(
                   this.varr(this.count, ev, this.plug[i], i)
                                        .join(this.separator), i));
        }
    }                            ////// "private" instance helpers for compute()
    vfps(v, i = 0) {                 // v   = value
        if (this.func)               // fps = func, prefix, suffix
            v = this.func.apply(v);
        if (this.easee.attr.isTransform)
            return this.prefix[i] + v + this.suffix[i];
        else
            return v;
    }
    varr(c, ev, p, idx) {            // arr = array, for computing value lists
        let bi, v;                   // idx is element index for 2D array
        v = new Array(c);
        if (Is.def(idx)) {
            for (bi of this.bools.true)
                v[bi] = this.vnu(this.computer(ev, bi, idx), false, idx, bi);
            for (bi of this.bools.false)
                v[bi] = this.vnu(p[bi],                      true,  idx, bi);
        }
        else {
            for (bi of this.bools.true)
                v[bi] = this.vnu(this.computer(ev, bi),      false, bi);
            for (bi of this.bools.false)
                v[bi] = this.vnu(p[bi],                      true,  bi);
        }
        return v;
    }
    vnu(v, isP, i, j) {              // nu = numbers & units, isP = isPlug
        if (isP) {                   // plugs are strings, with units
            if      (Is.def(j)) this.number[i][j] = Attr.toNumber(v);
            else if (Is.def(i)) this.number[i]    = Attr.toNumber(v);
            else                this.number       = Attr.toNumber(v);
            return v;
        }
        else {                       // non-plugs are numbers, enforce max/min
            if (Is.def(j)) {
                this.number[i][j] = Math.max(this.min[i][j],
                                    Math.min(this.max[i][j], v));
                return this.number[i][j] + this.units;
            }
            else if (Is.def(i)) {
                this.number[i]    = Math.max(this.min[i],
                                    Math.min(this.max[i], v));
                return this.number[i]    + this.units;
            }
            else {
                this.number       = Math.max(this.min, Math.min(this.max, v));
                return this.number       + this.units;
            }
        }
    }
    /////////////////////////////////// the computers return a single number ///
    computeOne(ev) {                 // ease().value, units
        return this.factor           * ev + this.addend;
    }
    computeSub(ev, sub) {            // ease().value, f/a sub-value index
        return this.factor[sub]      * ev + this.addend[sub];
    }
    computeElm(ev, sub, idx) {       // ease().value, f/a sub index, elm index
        return this.factor[idx][sub] * ev + this.addend[idx][sub];
    }
    addOne(ev)           { return      ev + this.addend;           }
    addSub(ev, sub)      { return      ev + this.addend[sub];      }
    addElm(ev, sub, idx) { return      ev + this.addend[idx][sub]; }
}             ///////////////////////// end class Easer ||||||||||||||||||||||||
///////////////////////////////////////|||||||||||||||||||||||||||||||||||||||||
class Geaser extends Easer {         // Easer for CSS gradients and for the SVG
    constructor(ee, elms) {          // <path d> and <poly* points> attributes.
        let b, bi, c, f, i, j, k, l, la, lb, lp, m, n1, nb, ne, o, p, s, v, x;
        super(ee);                   // only one arg: creates this and returns
        l  = elms.length;            // if (>1 elms) value structure cannot vary
        f  = ee.func;
        x  = ee.attr.getu(elms);     // x = parsed existing values object
        m  = Is.A(ee.mask) ? ee.mask : [ee.mask];
        la = m.length;               // mask = array of indices into x.nums[i][]
        nb = Number(x.numBeg && (m[0] == 0));
        ne = x.numEnd && (m[la-1] == x.nums[0].length - 1);
        c  = la * 2 - (nb && ne) + !(nb || ne);
        lp = c - la;                 // addend/plug are interwoven, every other:
        p  = Easer.arrayz(c, l, ""); // their lengths might differ by 1, and
        b  = Object.create(null);    // either one can appear first and/or last.
      //b.bools = Array.from({length:c }, (_, i) => (nb + i) % 2);
        b.true  = Array.from({length:la}, (_, i) => !nb + (i * 2));
        b.false = Array.from({length:lp}, (_, i) =>  nb + (i * 2));
                                     // parse the addend, factor, max, and min
        o = this.constructor.zobj(ee.max, ee.min, ee.addend, ee.factor,
                                  false,  false,  b, ee.attr.plug());
        o.forEach((v) => {           // using numbers, not strings
            v.izF       = Easer.izFull(v, 2, c);
            this[v.key] = Easer.zap(v, x.nums, c, l, ee.byElm, m);
        });
        n1 = nb - 1;                 // parse the plug, using string values
        lb = b.false.length;
        for (i = 0; i < l; i++){
            v = x.vals[i];
            s = x.seps[i];
            for (j = n1; j < lb; j++) {
                bi = b.false[j];     // j can start at -1
                lp = m[j + 1] || v[i].length;
                for (k = (j < 0 ? 0 : m[j] + 1); k < lp; k++)
                    p[i][bi] += s[i][k] + v[i][k];
                p[i][bi] += s[i][k];
            }
        }
        this.type = 2;               // always all 2D arrays
        this.plug = p;       this.bools = b;    this.easee = ee;
        this.elms = elms;    this.count = c;    this.units = "";

        this.number    = this.constructor.arrayz(c, l);
        this.computer  = this.factor ? this.computeElm : this.addElm;
        this.separator = "";
        Object.seal(this);
    }
}             ///////////////////////// end class Geaser |||||||||||||||||||||||
///////////////////////////////////////|||||||||||||||||||||||||||||||||||||||||
class Teaser {                       // Easer for transforms, wraps 1+ Easers in
    constructor(ee, elms) {          // this.easers by Func instance.
     let a, b, bfc, c, f, fc, fi, fn, func, i, l, m, max, min, p, pre, suf, val;
        this.easee  = ee;
        this.elms   = elms;
        this.easers = new Map();     // key = Func, value = Easer
        this.values = new Map();     // multi-easers: previous frame's values
        this.idx    = 0;
        func = ee.func;
        if (!Is.A(func))
            func = [func];
        this.funcs = func;           // one func per writable function
        fc  = func.length;           // func count
        bfc = fc > 1;                // it's an array even if it's only one func
        c   = Array.from({length:fc}, (_, i) => ee.attr.count(func[i]));
        l   = elms.length;           // new Easer() arrays by func by element
        pre = Easer.arrayz(l, fc, "");
        suf = Easer.arrayz(l, fc, "");
        val = Easer.arrayz(l, fc, "");
        if (!ee.set) {              //\ get existing values by element
            let v = ee.attr.get(elms);
            if (v) {
                let felm, j, k, s, z;// this.felms = by elm by func, for apply()
                this.felms = new Array(l);
                                     // loop by element: parse existing values
                for (i = 0; i < l; i++) {
                    if (v[i]) {      // split into duples: func.name, arg(s)
                        felm = new Set();
                        p = "";      // every has prefix, only last has suffix
                        z = -1;      // z tracks last func index for suffix
                        s = v[i].split(E.func);
                        s.length--;  // always an extra trailing array element
                                     // parse one value: maintain func order
                        for (j = 0, k = 0; j < s.length; j++) {
                            fn = s[j++].trim();
                            fi = func.indexOf(FN[fn]);
                            if (fi >= 0) {
                                felm.add(FN[fn]);
                                val[fi][i] = s[j].trim();
                                pre[fi][i] = p;
                                p = "";
                                z = fi;
                                k++;
                            }
                            else
                                p += fn + E.lp + s[j] + E.rp + E.sp;
                        }
                        if (p && z >= 0)
                            suf[z][i] = E.sp + p.trimEnd();
                        if (k < fc) {// push non-existent funcs to the end
                            for (j of func)
                                felm.add(j);
                        }
                        this.felms[i] = Array.from(felm);
                    }                // end if (v[i])
                    else             // else no existing value for this element
                        this.felms[i] = func;
                }                    // end for (i by element)
            }                        // end if (v): !v same as (ee.set == E.set)
        }                           //\ end if (!ee.set) get existing values
        for (i = 0; i < fc; i++) {  //\ compute the bools and create the Easers
            fi = func[i];
            fn = fi.name;
            if (bfc) {
                f = Attr.ztf(ee.factor, fi, i);  m   = Attr.ztf(ee.mask, fi, i);
                a = Attr.ztf(ee.addend, fi, i);  max = Attr.ztf(ee.max,  fi, i);
                p = Attr.ztf(ee.plug,   fi, i);  min = Attr.ztf(ee.min,  fi, i);
            }
            else {
                f = ee.factor;   p = ee.plug;   max = ee.max;
                a = ee.addend;   m = ee.mask;   min = ee.min;
            }
            if (c[i]) {              // compute b: the bools object for fi
                m = Attr.svgRot(ee.attr.svg, fi, m, l, f, a, p);
                b = Attr.toBools(m, c[i]);
            }
            this.easers.set(fi,      // one easer per func
                new Easer(ee, elms, fi,
                          Is.A(ee.units) ? ee.units[i] : undefined,
                          c[i], val[i], pre[i], suf[i], f, a, p, max, min, b));
        }
        Object.seal(this);
    }
    /////////////////////////////////// end constructor() //////////////////////
    apply(e) { //////////////////////// apply() maintains func order by element
        let ee, ev, ez, v;
        ee = this.easee;
        ez = ee.eases;
        v  = new Map();
        if (e) {                    //\ compute & store values by Func instance
            if (ez)                  // if (ez) then multiple eases, processed
                return this;         // at the end of easeEm(), using each ez.e
            ev = ee.evaluate(e);     // property, and evaluate(noFalse = true).
            if (ev === false)
                return;              // noop
            this.easers.forEach((er, f) => { v.set(f, er.compute(ev)); });
        }
        else {                       // process multiple eases
            this.easers.forEach((er, f) => {
                e  = ez.get(f).e;
                ev = ee.evaluate(e);
                v.set(f, ev === false || e.status == E.pausing
                       ? this.values.get(f) : er.compute(ev));
            });
            this.values = v;
        }                           //\ apply the values to the elements
        if (ee.easy.byElm) {         // easy.byElm is loop by element
            if (Is.def(this.turn)) { // at the turning point, set values on two
                let tv = new Map();  // elements: current and next//!!easy.break
                this.easers.forEach((er, f) => {
                    tv.set(f, er.compute(this.turn));
                });
                this.applyOne(ee.attr, tv, this.idx);
                ee.turn(this);
            }
            this.applyOne(ee.attr, v, this.idx);
        }
        else {
            for (let i = 0; i < this.elms.length; i++)
                this.applyOne(ee.attr, v, i);
        }
        if (ee.peri)                //\ run the callback
            ee.peri(this, e);
    }
    applyOne(attr, v, i) { ////////// applyOne() helps apply()
        let j, s, vf;
        for (s = "", j = 0; j < this.funcs.length; j++) {
            vf = v.get(this.felms ? this.felms[i][j] : this.funcs[j]);
            s += (Is.A(vf)  ? vf[i] : vf) + E.sp;
        }
        Attr.set(attr, this.elms[i], s.trimEnd());
    }
}             ///////////////////////// end class Teaser |||||||||||||||||||||||
///////////////////////////////////////|||||||||||||||||||||||||||||||||||||||||
class Easee {                        // Object of: "The easer eases the easee."
    constructor(o, ez) {
        this.set = o.set;    this.attr = o.attr;    this.easy = ez;
        this.min = o.min;    this.mask = o.mask;    this.peri = o.peri;
        this.max = o.max;    this.plug = o.plug;    this.eval = o.eval;
        this.gpu = o.gpu;            // invert the leg value to simplify apply()
        this.leg = o.leg == E.return  ? E.outward
                 : o.leg == E.outward ? E.return  : undefined;

        this.value = Is.def(o.value) ? o.value : (o.eval ? true : undefined);
        this.func  = o.func  || o.attr.func;
        this.units = o.units || o.attr.unitz(this.func);
        this.byElm = o.byElm || o.byElement;
        this.is1m  = o.is1m  || o.oneMinus || o.complement;
        this.isEnd = Number(o.isEnd || Is.def(o.end));
        this.count = o.attr.count(o.func);
        this.isGDP = o.attr.isDPoints || (o.func && o.func.isGradient)
                  || o.set == E.net; // forces Geaser: dx, dy, x, y, rotate are
                                     // optionally unstructured w/<text>,<tspan>
        this.addend = Is.def(o.addend) ? o.addend : o.start;
        this.factor = Is.def(o.factor) ? o.factor
                       : Is.def(o.end) ? o.end : o.distance;
                                     // this syntax gets existing factors (null)
        if (!Is.def(this.factor) && this.is1m && this.addend === 0)
            this.factor = null;
                                     // elms must be processed second-to-last
        this.constructor.elmz(this, o.elm || o.elms || o.element || o.elements);

        this.eases = o.eases || o.easy;
        if (this.eases) {            // multi-ease transforms processed last
            if (Is.A(this.eases)) {  // there must be >1 func, and func is array
                let fez = new Map();   // this.eases ends up as a map Func => Easy
                this.func.forEach((f, i) => {
                    fez.set(f, this.eases[i] || ez);
                    if (this.eases[i])
                        this.eases[i].targets.push(this);
                });
                this.eases = fez;
            }
            else {
                if (!Is.def(this.eases.get)) {
                    let fez = new Map();
                    Object.entries(this.eases).forEach(([fn, easy]) => {
                        fez.set(FN[fn], easy);
                        easy.targets.push(this);
                    });
                    this.eases = fez;
                }
                this.func.forEach((f) => {
                    if (!this.eases.has(f))
                        this.eases.set(f, ez);
                });
            }
        }
        Object.seal(this);
    }
    /////////////////////////////////// for reusing an instance w/alternate elms
    set    elms(elms) { this.constructor.elmz(this, elms); }
    static elmz(ee, elms) {          // kludgy to call setter from constructor
        elms = Attr.elmArray(elms);
        ee.easer = !elms ? elms : (ee.attr.isTransform ? new Teaser(ee, elms)
                                           : (ee.isGDP ? new Geaser(ee, elms)
                                                       : new  Easer(ee, elms)));
    }
    /////////////////////////////////// used by Easer and Teaser.apply() ///////
    evaluate(e) {
        if (this.leg == e.status    // this.leg is reversed: outward vs return
        || (this.leg == E.return && e.status == E.arrived)
        || (this.eval && this.eval(e) !== this.value))
            return false;
        else
            return this.is1m ? 1 - e.value : e.value;
    }
    turn(er) {                       // for loops by element, er = easer
        if (++er.idx == er.elms.length)
            er.idx = 0;
        er.turn = undefined;
    }
}             ///////////////////////// end class Easee ||||||||||||||||||||||||
/////////////////////////////////////|||||||||||||||||||||||||||||||||||||||||||
class Easy {                         // Outermost in the Easy instance hierarchy
    constructor(zero = 0, time = 0, type = E.in,  pow = 1, start, end, wait = 0,
      /* trip()     */  mid, pause, type2= type,  pow2= pow,      end2,
      /* looping    */  turns = 1, breaK, byElm,
      /* callbacks  */  pre, peri, post,
      /* RAF.test() */  gpu)
    {
        this.zero = zero;    this.type  = type;     this.pow  = pow;
        this.time = time;    this.type2 = type2;    this.pow2 = pow2;
        this.wait = wait;    this.byElm = byElm;    this.pre  = pre;
        this.dly  = wait;    this.break = breaK;    this.peri = peri;
        this.mid  = mid;     this.turns = turns;    this.post = post;
        this.gpu  = gpu;     this.volte = turns;    this.fois = turns;
                                     // volte = Italian, fois = French
        this.targets = [];           // targets is an array of Easee instances
        if (type == E.increment) {
            this.increment = pow;    // fully encapsulating incremental value
            this.base      = 0;      // changes means managing a base value too.
        }
        else if (Is.def(end)) {      // if (!Is.def(end)) start is ignored
            this.start = Is.def(start) ? start : 0;
            this.dist  = end - this.start;
            this.end   = end;
        }
        else {
            this.start = 0;
            this.end   = 1;
        }

        if (!mid) {                  // one-way, one-leg trip
            this.func  = this.ease;
            this.pause = 0;
        }
        else {                       // two-leg trip, round-trip or otherwise
            this.func  = this.trip;
            this.pause = pause ? mid + pause : mid;
            this.time2 = time - this.pause;
            if (Is.def(end2)) {      // return destination fully specified
                this.dist2 = end2 - end;
                this.end2  = end2;
            }
            else if (this.dist) {    // default to round trip
                this.dist2 = this.dist * -1;
                this.end2  = this.start;
            }
            else {                   // fall back to raw ease() return value
                this.dist2 = -1;
                this.end2  =  0;
            }
        }
    } ///////////////////////////////// this is extensible, not sealed /////////
    static create(o) {  /////////////// create() has named args, flex arg order
        return new Easy(o.zero, o.time,
                        o.increment ? E.increment : o.type,
                        o.increment || o.pow,
                        o.start, o.end,  o.wait, o.mid, o.pause,
                        o.type2, o.pow2, o.end2,
                        o.turns || o.plays || o.repeats + 1 || undefined,
                        o.break,
                        o.byElm || o.byElement,
                        o.pre, o.peri, o.post, o.gpu);
    }
    /////////////////////////////////// reuse() resets the basics to go again //
    reuse(time = this.time, wait = this.dly) {
        this.time  = time;           // dly = "delay", synonym of "wait"
        this.wait  = wait;           // this.wait gets set to 0 in easeMe()
        this.turns = this.fois;      // .turns and .wait have backup values
        if (!Is.def(this.zero) || this.zero)
            this.zero = 0;           // preserve null and false values
        if (this.increment)
            this.base = 0;
    }
    /////////////////////////////////// .total & Easy.last() help set this.post
    static last(it) {
        let ez;
        it.forEach((v) => { if (!ez || ez.total <= v.total) ez = v; });
        return ez;
    }
    get total() { return this.wait + this.time; }
    /////////////////////////////////// 4 ways to add a target (class Easee) ///
    add(o) {                         //#1. flex arg order, named args, alt names
        let ee = new Easee(o, this); // ...see Easee.constructor() for alt names
        this.targets.push(ee);
        if (this.byElm && ee.easer) {//    if (!o.elms) ee.easer = undefined
            this.turns = Math.max(this.turns,
                                  this.volte * ee.easer.elms.length);
            this.fois  = this.turns;
        }
        return ee.easer || ee;
    }
                                     //#2. By: factor is multiplier, distance
    addBy(attr, elms, factor, addend, func, mask, plug, units) {
        return this.constructor.zadd(this,  0, arguments);
    }
                                     //#3. To: end is endpoint, destination
    addTo(attr, elms, end,    start,  func, mask, plug, units) {
        return this.constructor.zadd(this,  1, arguments);
    }
                                     //#4. 1m: 1 - ease().value, the complement
    add1m(attr, elms, factor, addend, func, mask, plug, units) {
        return this.constructor.zadd(this, -1, arguments);
    }
    static zadd(ez, type, args) {    // a helper for the addXX() functions
        let o   = Object.create(null);
        o.isEnd = type > 0;
        o.is1m  = type < 0;   o.factor = args[2];   o.mask  = args[5];
        o.attr  = args[0];    o.addend = args[3];   o.plug  = args[6];
        o.elms  = args[1];    o.func   = args[4];   o.units = args[7];
        return ez.add(o);
    }
    /////////////////////////////////// the animation methods //////////////////
    static easeEm(it, now) {         //\ Easy.easeEm() is the batch easeMe()
        let combo, e, i, v;          //\ Em = 'em = them, it = iterable
        v = { status:E.arrived };    // default return value is safest, simplest
        if (!Is.A(it))               // array, map, set, object, or error
            it = it.values() || Object.values(it);

        combo = new Set();
        for (i of it) {
            if (Is.def(i.zero)) {
                e = i.easeMe(now, combo);
                if (!e.status)       // final value set, stop animating i
                    i.zero = undefined;
                if (e.status > v.status)
                    v = e;
            }
        }
        combo.delete(undefined);     // combined transforms
        combo.forEach((t) => { t.apply(); });

        return v;                    // one e returned, the rest are in it[n].e
    }
    easeMe(now, combo = new Set()) {//\ easeMe() calculates and applies values
        switch (this.zero) {         // this.zero should never be NaN
        case null:                   // undefined = pre-handled by Easy.easeEm()
            break;                   // null      = now is already adjusted
        case false:                  // false     = run once, set final values
            now = Infinity;          // 0         = set it to now, skip 1st frame,
            break;                   //             because timeStamp was unknown.
        case 0:                      // truthy    = use it to adjust now
            this.zero = now;
            if (this.pre && !this.wait)
                this.pre(this);      // does not call ease(), must set this.e
            this.e =     { status:E.outward, value:(this.start || 0) };
            return this.e;
        default:
            now -= this.zero;
        }
        if (this.wait) {             // wait is handled here, not ease()
            if (this.wait > now) {   // does not call ease(), must set this.e
                this.e = { status:E.waiting, value:(this.start || 0) };
                return this.e;
            }
            if (this.pre)
                this.pre(this);
            this.zero += this.wait;
            now       -= this.wait;
            this.wait  = 0;
        }
        let e = this.func(now);
        if (e.status !== E.pausing && !this.noop)
            this.targets.forEach((t) => { combo.add(t.easer.apply(e)); });
        if (this.peri)
            this.peri(this);         // peri() runs every time after apply()
        if (!e.status && this.post)
            this.post(this);
        return e;
    }
    /////////////////////////////////// the easing methods /////////////////////
    // ease(now, duration, type, power, start, distance, end)
    //  now   == elapsed animation time (milliseconds)
    //  time  == animation duration
    //  type  == E.in, E.out, E.increment : E.in = default = 0 = falsy
    //  pow   == power for Math.pow()
    //  start == optional starting point, required if dist specified
    //  dist  == optional distance, required if start specified
    //  end   == optional cached version of start + dist
    //  returns: {value, status}
    //   status: 0 = ending (E.arrived), 4 = running (E.outward)
    ////////////////////////////////////////////////////////////////////
    // trip() goes there and back, it has the same args as ease() plus:
    //  mid   = required end time for go portion
    //  pause = optional wait time between go and return portions
    //  type2, pow2, dist2, end2 are optional return leg values
    //  additional statuses: 3 = E.mid, 2 = E.pausing, 1 = E.return
    //  easeMe() returns the one remaining status val: 5 = E.waiting
    ease(now, time = this.time,  type = this.type, pow = this.pow,
             start = this.start, dist = this.dist, end = this.end)
    {
        let e, n, v;
        if (now >= time) {           // now always < time if outward leg of trip
            v = this.increment ? this.base + this.increment : end;
            if (--this.turns > 0) {
                if (this.zero !== false)
                    this.zero += this.time;
                now -= time;         // if (return leg) time != this.time
                if (this.mid) {      // if (return leg) flip direction
                    this.pastMid = false;
                    if (this.increment)
                        this.increment *= -1;
                    else {
                        start = this.start;
                        dist  = this.dist;
                    }
                }
                if (this.byElm)
                    this.targets.forEach((t) => { t.easer.turn = v; });
            }
            else
                e = {status:E.arrived} ;
        }
        if (!e) {
            e = {status:E.outward};
            if (!this.noop) {
                if (this.increment) {
                    this.base += this.increment;
                    v = this.base;   // better than updating easer.addend
                }
                else {
                    n = now / time;
                    v = type ? 1 - Math.pow(1 - n, pow) : Math.pow(n, pow);
                    if (dist)
                        v = start + (dist * v);
                }
            }
        }
        if (now < Infinity)          // Infinity == jump to end, but
            this.now = now;          // leave this.now intact.

        e.value = v;
        this.e  = e;
        return e;
    }
    trip(now) {
        let e;
        if (now < this.mid)          // if (!pause) it never arrives at end
            return this.ease(now, this.mid);
        if (now < this.pause) {
            e = {value:(this.increment ? 0 : this.end)};
            if (this.pastMid)
                e.status = E.pausing;
            else {
                e.status = E.mid;
                if (this.increment)
                    this.increment *= -1;
                this.pastMid = true;
            }
            this.e = e;              // does not call ease(), must set this.e
            return e;
        }
        now -= this.pause;
        e    = this.ease(now, this.time2, this.type2, this.pow2, this.end,
                              this.dist2, this.end2);
        if (e.status)
            e.status = E.return;
        return e;
    }
} ///////////////////////////////////// end class Easy |||||||||||||||||||||||||
//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||||||||||| RAF classes ||||||||||||||||||||||||||||
//||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
class ACues {                        // ACues: a barebones cues list
    constructor(func, cues, times, zero) {
        this.init(...arguments);
        Object.seal(this);
    }
    init(func, cues = [], times = [], zero = 0) {
        this.func = func;   this.times = times;   this.cues = cues;
        this.zero = zero;   this.index = 0;       this.last = cues.length - 1;
    }
    push(t, attr, elms, v, set, arg3, arg4, arg5, arg6) {
        let obj = Object.create(null);
        this.cues .push(obj);
        this.times.push(t);
        this.last++;
        if (attr) {
            obj.args = [elms, v, arg3, arg4, arg5, arg6];
            switch (set) {
                case E.let: obj.func = attr.let; break;
                case E.net: obj.func = attr.net; break;
                default:    obj.func = attr.set;
            }
        }
        return obj;
    }
    run(now) {
        if (this.zero === 0) {
            this.zero = now;         // adjust the times now: faster, simpler
            this.times.forEach((v, i, a) => {a[i] = v + now;});
        }
        if (now >= this.times[this.index]) {
            let cue = this.cues[this.index];
            if (cue.func)
                cue.func(...cue.args);
            else
                this.func(cue, this);
            this.index++;            // must wait until after this.func()
        }
        return(this.index <= this.last);
    }
}             ///////////////////////// end class ACues ||||||||||||||||||||||||
///////////////////////////////////////|||||||||||||||||||||||||||||||||||||||||
class AFrame {                       // AFrame: the animation frame manager
    constructor() {
        this.frame = undefined;   this.min = undefined;   this.func = undefined;
        this.cues  = undefined;   this.fps = undefined;   this.skip = undefined;
        this.eases = [];          this.gpu = undefined;   this.gpuf = undefined;
        this.last  = Object.create(null);
        Object.seal(this);
    }
    /////////////////////////////////// 2 types of target: Easy and ACues //////
    add(o) {                         // adds an instance of Easy to this.eases
        return this.push(o.zero, o.time, o.type,  o.pow, o.start, o.end, o.wait,
                         o.mid, o.pause, o.type2, o.pow2,         o.end2,
                         o.turns || o.plays || o.repeats + 1 || undefined,
                         o.break,
                         o.byElm || o.byElement,
                         o.pre, o.peri, o.post, o.gpu);
    }                                // raw arguments version of add()
    push(zero, time, type,  pow, start, end, wait,
         mid, pause, type2, pow2,       end2,
         turns, breaK, byElm, pre, peri, post, gpu)
    {
        let ez = new Easy(...arguments);
        this.eases.push(ez);
        if (Is.def(this.gpu))
            this.constructor.zgpu(ez, this);
        return ez;
    }
    cue(func, cues, times, zero) {   // creates and returns this.cues
        this.cues = new ACues(...arguments);
        return this.cues;
    }
    /////////////////////////////////// animation methods //////////////////////
    animate(timeStamp) {             // cues first so they can trigger eases...
        if (this.cues && !this.cues.run(timeStamp))
            this.zend("cues",  null);
        if (this.eases.length && !Easy.easeEm(this.eases, timeStamp).status)
            this.zend("eases", []);

        if ((this.func && this.func(this)) || this.cues || this.eases.length)
            this.frame = requestAnimationFrame((t) => this.animate(t));
        else
            this.frame = undefined;
    }
    cancel(arrive, reset)  {
        if (Is.def(this.frame)) {
            cancelAnimationFrame(this.frame);
            this.frame = undefined;
            if (arrive) {
                if (this.cues) {
                    this.cues.index = this.cues.last;
                    this.cues.run(Infinity);
                }
                if (this.eases)
                    Easy.easeEm(this.eases, Infinity);
            }
            if (reset) {
                if (this.cues)         this.zend("cues",  null);
                if (this.eases.length) this.zend("eases", []);
            }
            return true;
        }
    }
    start()   {
        if (!Is.def(this.frame)) {
            this.frame = requestAnimationFrame((t) => this.animate(t));
            return true;
        }
    }                                // test() is an alternative to start()
    test(timeStamp, ez, min, func, skip = 0) {
        if (!timeStamp) {            // use the default (ez.zero = 0), so that
            ez.aframe = this;        // easeMe() starts counting at 0, not 1.
            ez.frames = 0;                       this.min  = min;
            ez.peri   = this.constructor.zpp;    this.gpuf = func;
            ez.post   = this.constructor.zfps;   this.skip = skip;
        }
        this.frame = requestAnimationFrame(
                     (t) => (this.skip-- > 0 ? this.test(t) : this.animate(t)));
    }
    zend(key, val) {                 // zend() is "private", not for public use
        this.last[key] = this[key];
        this[key]      = val;
    }
    /////////////////////////////////// static helpers /////////////////////////
    static zfps(ez) {                // zfps() computes .fps: frames per second
        let af = ez.aframe;          // sets .gpu to pass/fail: .fps >= minimum
        af.fps = ez.frames / (ez.time / 1000);
        af.gpu = af.fps >= af.min;
        for (let t of af.eases)
            AFrame.zgpu(t, af);
        if (af.gpuf)
            af.gpuf();
        delete ez.aframe;  delete ez.frames;  delete ez.peri;  delete ez.post;
    }
    static zgpu(ez, af) {            // zgpu() uses 0 == false and 1 == true
        if (Is.def(ez.gpu) && ez.gpu != af.gpu) {
            if (ez.gpu === false || ez.gpu === true)
                ez.zero = false;     // tells easeEm() to do nothing
            else
                ez.noop = true;      // tells easeMe() to do almost nothing
        }
    }
    static zpp(ez) { ez.frames++; }  // zpp() counts frames
}                         ///////////// end class AFrame |||||||||||||||||||||||
const RAF = new AFrame();            // one instance is all you need
////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Home Page //////////////////////////////
////////////////////////////////////////////////////////////////////////////////
let asp, beam, bFF, bg, butts, comp, ctx, fx, grain, hand, hasAgreed, idler,
main, mcH, mcW, menus, nbsp, noise, share, shirt, song, src, stdDev, svg, vb, vol;

const vbC   = [-6,-10,444,692]; // hasAgreed viewBox, C for constant
const seedy = 999;              // range of random integer values for seed
const fps   =  33;              // ~30fps for grainy() and staticky()
const oneY  =  32;              // line height = font size = em unit
const oneX  =  18.75;           // char width in px, at 1em == 32px
const tick  =  55;              // 55ms = unit of time for typist, songMenu
const stat  =   0;              // indices into fx & src arrays of audio samples
const neon  =   1;

const ids   = { body : "body",         bord : "border",
                logo : "logo",         ctrl : "controls",
                butt : "Butt",         menu : "Menu",
                song : "song"                              };

const mouse = { over : "mouseover",   enter : "mouseenter",
                out  : "mouseout",    leave : "mouseleave",
                down : "mousedown",   up    : "mouseup",
                move : "mousemove",   click : "click"      };

const touch = { start:"touchstart", end:"touchend", move:"touchmove" };

// For !hasAgreed animations only ///////////////////
let audio, body, defs, div, glob, keys, logo, typist;

const yesNo = ["hellO,",
               " my name Is sIdeways.",
               " *welcOme tO my sIte*",
               ">sOunds abOund!",
               " yOu wanna heaR them?",
               "      YES>  NO>"];

let glows   = ["songButt", "shareButt", "downButt",   "streamButt",
               "spelunk",  "mute",      "faq", "fuq", "bio", "smaws", "s",
               "agree",    "smiley",    "yes", "no"];

// songMenu: const songs and class Song /////////////
const songs = [
//    {title:"RaInbow Pussy",     name:"" },
//    {title:"StupId Fuck",       name:"" },
//    {title:"TheUnIveRsalSOund", name:"TUS_" , work:"1c-", default:true},
//    {title:"WInky In YOuR Bum", name:"WIYB_", work:"1b-"},
//    {title:"Ass-FuckIng Slut",  name:"AFS_" , work:"1a-"}
    {title:"RaInbow POOpy",     name:"" },
    {title:"StupId Fink",       name:"" },
    {title:"TheUnIveRsalSOund", name:"TUS_" , work:"1c-", default:true},
    {title:"PInky In My Thumb", name:"PIYT_", work:"1b-"},
    {title:"Butt-BumpIng Nut",  name:"BBN_" , work:"1a-"}
];
class Song {                                        // encapsulates songMenu and
    constructor(glow, glo) {                        // song title <text> control
        let d, elm, g, i, id, l, rect, sel, si, t, text, top, y;
                               //>> Update this date for every new release. <<//
        this.next   = new Date(Date.UTC(2018, 11, 22)).getTime();
        this.msecs  = 24 * 60 * 60 * 1000;
        this.chars  = 17;                           // max chars in song title
        this.oneY   = 31.2;                         // post-agree font size
        this.oneX   = oneX * (this.oneY / oneY);    // char space @ 1em = 31.2px
        this.max    = this.buttX(true);             // max x-value for songButt
        this.text   = svg.getElementById(ids.song); // <text> for song title
        this.butt   = this.text.nextElementSibling; // button show/hide songMenu
        this.menu   = menus.song.lastElementChild;
        this.inner  = this.menu .previousElementSibling;
        this.outer  = this.inner.previousElementSibling;
        this.offI   = 13;                           // inner/outer height offsets
        this.offIO  = AT.y.getn(this.inner) - AT.y.getn(this.outer);
        this.offIO2 = 2 * this.offIO;
        this.offO   = this.offI + this.offIO2;      // artist = me in guid form
        this.artist = "8539fb1c-2d33-471c-a512-364542908d90";
        this.album  = window.location.hostname.includes("g")
                    ? "Censored" : "Uncensored";    // album depends on site url
        localStorage.setItem(this.artist + "album", this.album);
        sel = localStorage.getItem(this.artist + this.album + ids.song);
        elm = this.menu.firstElementChild;          // "mother" for cloning
        t = AT.y.getn(elm.firstElementChild);       // t for top
        y = AT.y.getn(this.text);
        d = y - t;                                  // d for delta
        l = songs.length
        for (i = 0, g = elm; i < l; i++) {
            if (i) {
                g = elm.cloneNode(true);            // <g><rect><text></g>
                this.menu.appendChild(g);
            }
            si   = songs[i];
            rect = g.firstElementChild;             // class="none" has events
            text = g. lastElementChild;             // song title
            text.textContent = si.title;
            AT.di.set(rect, i);                     // data-index attribute
            AT.h .set(rect, this.oneY);
            AT.y .set(rect, y - d);
            AT.y .set(text, y);
            y  = this.round(y + this.oneY);         // y++
            id = si.name;
            if (id) {                               // songs have glows, events
                cloneGlow(glow.elm, id, glo, glow.par, glow.sib);
                rect.id = id;
                si.blur = defs.getElementById(id + glo).firstElementChild;
                AT.filter.set(text, E.hash + id + glo);
                addMouseTouch(rect, mouseIt, clickIt, touchIt);
            }
            else {                                  // no id = future release
                AT.filter.set(text, "#s" + glo);    // no click event, #s-glo
                addMouseTouch(rect, mouseIt, false,   touchIt);
            }
            if (sel == id || (!sel && si.default)) {// the selected song
                this.idx = i;
                this.sel = g;                       // sel = "selected"
                this.text.textContent = si.title;
                top = this.round(AT.y.getn(rect) - t);
            }
        }
        this.base = t;
        this.y    = top;
        this.top  =-top;
        this.oneH = this.offO + d;
        this.h    = this.oneH;
        AT.h   .set(this.outer, this.h);
        AT.h   .set(this.inner, this.offI + d);
        AT.tSVG.set(this.outer, [0, top], FN.t);
        AT.tSVG.set(this.inner, [0, top], FN.t);
        AT.tSVG.set(menus.song, [0,-top], FN.t);
        AT.tSVG.set(this.butt,  this.max, FN.t);
    }
    ////////////////////////////////////////////////////////////////////////
    // public methods
    select(target) {                //\ called by clickIt() on song in menu
        this.sel = target.parentNode;// set localStorage now so that refresh
        this.idx = AT.di.getn(target);// corrects any stray songMenu error.
        const si = songs[this.idx];
        this.text.textContent = si.title;
        localStorage.setItem(this.artist + "workNo", si.work);
        localStorage.setItem(this.artist + this.album + ids.song, si.name);
    }
    open() {                        //\ open goes until it runs out of elements
        let cue, q, t;
        t = 200;                     //1) slide songButt right to max
        this.moveButt(t, 0, undefined, this.x, this.max);
        t = this.fadeMenu(t);        //2) fade in songMenu
        q = this.prepare(this.oneY); //3) open the menu
        while (q.elmU || q.elmL) {
            cue = this.nextCue(q.cues, t, q.elmU, q.diff);
            t  += tick;
            q.elmU = this.push(cue, q.elmU, q.sibU, q.diff);
            q.elmL = this.push(cue, q.elmL, q.sibL, q.diff);
        }
        Attr.visible(menus.song, true);  // in addition to opacity, for events
        Attr.visible(this.sel,   true);
        this.isOpen = true;
        RAF.start();
    }
    close(buttOnly) {               //\ close relies on this.sel this.y this.top
        let t, w;                   //\ also called via loadIt() and agreed()
        if (!buttOnly) {             // menu is open, close it
            let cue, l, o, u;        // u = upper, l = lower
            let z = 9;              // failsafe against infinite loop
            w = 0;
            o = this.prepare(-this.oneY);
            do {                     //1) close the menu
                u = this.isUL();
                l = this.isUL(true, u);
                if (u || l) {
                    cue = this.nextCue(o.cues, w, u, o.diff);
                    w  += tick;
                    if      (this.isSelCue(o.elmU))
                        o.elmL = this.selCue(cue, o.elmL, o.sibL,-o.diff, l, true);
                    else if (this.isSelCue(o.elmL))
                        o.elmU = this.selCue(cue, o.elmU, o.sibU, o.diff, u);
                    else {
                        if (u) o.elmU = this.push(cue, o.elmU, o.sibU, o.diff);
                        if (l) o.elmL = this.push(cue, o.elmL, o.sibL, o.diff);
                    }
                }
                else
                    break;
            } while (--z)
            if (!z) alert("An error has occurred. Please refresh the page.");
                                     //2) fade out songMenu
            w = this.fadeMenu(w, true);
            t = 200;
        }
        else {                       // buttOnly is for loadIt() and agreed()
            w = 0;                   // menu is already closed
            t = 500;
        }                            //3) slide songButt left to title's edge
        this.moveButt(t, w, this.constructor.post, this.max, this.buttX());
        this.isOpen = false;
        RAF.start();
    }
    ////////////////////////////////////////////////////////////////////////
    // callbacks: static because their "this" is an ACues or Easy instance
    static cue(cue, ac) {           //\ the run-time cue executor
        for (let elm of cue.elms)
            Attr.visible(elm, song.isOpen);

        AT.h.set(song.outer, cue.h);
        AT.h.set(song.inner, cue.h - song.offIO2);

        if (Is.def(cue.y)) {
            AT.tSVG.let(song.outer, cue.y,   EZ.y, FN.t);
            AT.tSVG.let(song.inner, cue.y,   EZ.y, FN.t);
        }
        if (Is.def(cue.top))
            AT.tSVG.let(menus.song, cue.top, EZ.y, FN.t);

        if (!isMuted() && fx[nbsp])
            cBufSrc(fx[nbsp], vol).start();
    }
    static post() {                 //\ in spite of "opacity:0", songMenu covers
        Attr.visible(menus.song, false);
        Attr.visible(song.sel,   false);
    }                               //\ songButt and visibility controls events.
    ////////////////////////////////////////////////////////////////////////
    // "private" methods
    fadeMenu(w, is1m) {             //\ sets up songMenu fade in|out opacity
        let ez = this.animations.o;
        ez.reuse(ez.time, w);
        ez.targets[0].is1m = is1m;
        RAF.eases.push(ez);
        return w + ez.time;
    }
    moveButt(t, w, post, start, end) {
        let ez = this.animations.x; //\ sets up the songButt animation
        let er = ez.targets[0].easer.easers.get(FN.t);
        ez.reuse(t, w);
        ez.post = post;
        er.addend[E.x] = start;
        er.factor[E.x] = end - start;
        RAF.eases.push(ez);
        this.x = end;
    }
    buttX(toMax) {                  //\ puts both bits of logic in one place
        if (toMax)                   // called once by loadIt() to set this.max
            return 4 + (this.oneX * this.chars) + 9;
        else                         // called by this.close()
            return 4 + (this.oneX * this.text.textContent.length);
    }
    prepare(diff) {                 //\ makes open/close functions more readable
        let o  = Object.create(null);
        o.diff = diff;
        o.cues = RAF.cue(this.constructor.cue);
        if (diff > 0) {              // U = upper, L = lower
            o.sibU = "previousElementSibling";
            o.sibL = "nextElementSibling";
            o.elmU = this.sel[o.sibU];
            o.elmL = this.sel[o.sibL];
        }
        else {
            o.sibU = "nextElementSibling";
            o.sibL = "previousElementSibling";
            o.elmU = this.menu.firstElementChild;
            o.elmL = this.menu. lastElementChild;
        }
        return o;
    }
    nextCue(q, t, b, diff) {        //\ gets the next cue inside a for loop
        let cue  = q.push(t);
        cue.elms = [];
        if (b)
            this.roundCue(cue, "y", -diff);
        return cue;
    }
    push(cue, elm, sib, diff) {     //\ pushes a song element into the cue
        if (elm) {
            cue.elms.push(elm);
            this.roundCue(cue, "h", diff);
            return elm[sib];         // returns the appropriate sibling element
        }
    }
    isUL(isL, u) {                  //\ helps this.close() decide what to do
        if (!u)                      // this.oneH is an integer
            u = this.round(this.top + this.y)
        return isL ? Math.round(u + this.h) != this.oneH : u;
    }
    isSelCue(elm) {                 //\ makes this.close() more readable
        return(elm === this.sel &&
           this.round(AT.y.getn(elm.firstElementChild) - this.base + this.top));
    }
    selCue(cue, elm, sib, diff, b, isLower) {
        let i, l;                   //\ helps this.close() handle this.sel
        this.roundCue(cue, "top", diff);
        this.roundCue(cue, "y",  -diff);
        l = b ? 2 : 1;
        for (i = 0; i < l; i++)      // height adjustment is always negative
            elm = this.push(cue, elm, sib, -this.oneY);
        return elm;
    }
    roundCue(cue, prop, diff) {     //\ cleans up floating point garbage
        cue [prop] = this.round(song[prop] + diff);
        song[prop] = cue[prop];     //\ this.oneY == 31.2 == +/-diff
    }                               //\ rounds reliably, not speedily
    round(n, p = 1) { return Number(n.toFixed(p)); }
}
////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// document.body.onload() /////////////////
////////////////////////////////////////////////////////////////////////////////
function loadIt() {
    logNow("open");
    let glow, i, id, j, k, l, std3, tester, text, top, w, y;
    const glo = "-glo";                          // suffix for glow filter ids

    // Assume the user wants audio, get a head start on downloads
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    ctx = new AudioContext();
    vol = ctx.createGain();
    vol.connect(ctx.destination);
    vol.gain.setValueAtTime(0.6, 0);             // no need to fade up
    noise = ctx.createGain();                    // separate gain for fx[stat]
    noise.connect(ctx.destination);
    noise.gain.setValueAtTime(0, 0);             // starts muted, fades up
    fx  = [];                                    // non-keyclick samples (+nbsp)
    src = [];                                    // AudioBufferSourceNode array
    loadSample(fx, "static", stat);              //??this sample must load first
    loadSample(fx, "neon",   neon);              // this one is just easier here

    // Initialize global variables
    defs  = document.body.firstElementChild;     // the <svg> with the <defs>
    main  = document.getElementById("main");     // <main> container
    svg   = document.getElementById("svg");      // <svg> for logo/controls
    comp  = defs.getElementById("comp");         // static filter sub-element
    grain = defs.getElementById("grain");        // #static filter sub-element
    beam  = Object.create(null);
    hasAgreed = localStorage.getItem("agreed");

    body = new Map();                            // body contains 4 elements, by
    for (i of Object.values(ids).slice(0, 4))    // id, that comprise the waist-
        body.set(i, svg.getElementById(i));      // up humanoid w/screen head.

    bg    = Object.create(null);                 // background sizing is funky
    shirt = Object.create(null);                 // adjustWeave() requires shirt
    shirt.bF  = 10.797;
    shirt.elm = defs.getElementById("weave");
    bg.svg    = document.getElementById("bg");   // background <svg> element
    bg.static = bg.svg.children[0];              // tv static background
    bg.astro  = bg.svg.children[1];              // astronomical texture
    bg.wall   = bg.svg.children[2];              // wall shadow
    bg.shadow = defs.getElementById("wall");
    i = Math.max(window.screen.width, window.screen.height);
    sizeSvg(bg.svg, i, i);                       // square portrait & landscape
    w = i * 10;                                  // huge, like the sky
    AT.w.set(bg.astro, w);
    AT.h.set(bg.astro, i * 2);                   // 10:2 == 5:1 width:height
    i *= -1;
    bg.lastX = (w + i + i) * -1;                 // minimum translateX value
    bg.unitX =  1;
    bg.x     = -1;
    AT.x.set(bg.astro, i);
    AT.y.set(bg.astro, i);

    bFF = (bg.svg.clientHeight == 0);            // bFF == boolean for Firefox

    // Create glow filters for each set of elements, by id. This is necessary
    // because changing an element's filter url is highly unreliable. The
    // solution is to manipulate the stdDeviation on each blur element.
    butts    = Object.create(null);
    menus    = Object.create(null);
    glow     = Object.create(null);
    glow.elm = defs.getElementById("glow");
    glow.par = defs.firstElementChild;           // the <defs> element
    glow.sib = glow.elm.nextElementSibling;
    l = glows.length - (hasAgreed ? 4 : 0);      // last four are pre-agree only
    for (i =0; i < l; i++) {
        id = glows[i];
        butts[id] = Object.create(null);
        butts[id].rect = document.getElementById(id);
        butts[id].blur = cloneGlow(glow.elm, id, glo, glow.par, glow.sib);
        if (suffix(id) == ids.butt) {
            j = prefix(id);
            menus[j] = document.getElementById(j + ids.menu);
        }
    }
    stdDev = AT.sD.getn(glow.elm.firstElementChild);
    std3   = stdDev / 3;                         // unit of change for AT.sD
    AT.sD.set(butts.mute   .blur, stdDev - std3);// exceptions to the loop:
    AT.sD.set(butts.s      .blur, stdDev * 2);
    AT.sD.set(butts.spelunk.blur, stdDev * 2);
    if (!hasAgreed) {
        AT.sD.set(butts.agree .blur, stdDev + std3);
        AT.sD.set(butts.smiley.blur, stdDev - std3);
        delete butts.smiley;                     // not a button
    }                                            // additions to the loop:
    butts.s.blur.id = A.sD;                      // animated by the idler
    butts.mute.use = butts.mute.rect.previousElementSibling;
    delete butts.s;                              // not a button

    song = new Song(glow, glo);                  // set up songMenu

    // Set up the opening animations
    if (hasAgreed) {                             // post-agreement
        let t;
        muteIt(localStorage.getItem("muteHome"));
        nbsp = neon + 1;
        loadSample(fx, "space", nbsp);           // sample & share are async
        getShare();                              // start them asap

        vb = vbC;
        AT.vB.set(svg, vb);                      // must precede windowResize()
        initSvg();
        initLogo();
        initBody();                              // runs as a 1-frame animation
//        initAsterisks();

        t = 500;                                 // fade in bg.astro/wall
        RAF.push(0, t).addBy(AT.o, [bg.astro, bg.wall]);
        t += 500;
        initBeam("transporter", body, agreed,    // beam up the body/screen
    /* beam   */ {time:4000, wait:t, mid:2000, pause:500},
    /* object */ {time:2000, wait:t + 1500},
    /* extra  */ {time:4000, wait:t + 1500, mid:1500, pause:100, start:0, end:0.5,
                  type2:E.in, pow2:2},
                 "shapeStatic");

        tester   = beam.eases[0];
        beam.val = setInterval(staticky, fps);
        beam.eases.forEach((ez) => { RAF.eases.push(ez); });
    }
    else                                         // pre-agreement
        tester = initWelcome()

    // Launch it
    asp = vb[2] / vb[3];                         // target aspect ratio
    windowResize();                              // sets the target style.height
    if (hasAgreed) {
        adjustWeave();                           // must follow windowResize()
        sizeOn();
    }
    RAF.func = reWind;                           // onresize throttled by RAF
    logNow("load");
    RAF.test(0, tester, 24, gpuAdjust, 3);
}
// loadIt() helpers
function gpuAdjust() {               // called when gpu test finishes
    console.log("gpu : " + RAF.gpu + E.sp + RAF.fps.toFixed(2) + "fps");
}
function cloneGlow(elm, id, suffix, parent, sibling) {
    let node = elm.cloneNode(true);
    node.id  = id + suffix;
    parent.insertBefore(node, sibling);
    return(node.firstElementChild);  // returns the feGaussianBlur element
}
function initSvg() {                 // sets final resting state of svg
    AT.w  .cut(svg);
    AT.pAR.cut(svg);
    svg.style.marginLeft = "";
    svg.style.alignSelf  = "";
}
////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Event handling /////////////////////////
////////////////////////////////////////////////////////////////////////////////
function addMouseTouch(elm, mouseFunc, clickFunc, touchFunc) {
    if (mouseFunc) {
        elm.addEventListener(mouse.enter, mouseFunc, false);
        elm.addEventListener(mouse.leave, mouseFunc, false);
        elm.addEventListener(mouse.down,  mouseFunc, false);
        elm.addEventListener(mouse.up,    mouseFunc, false);
    }
    if (clickFunc)
        elm.addEventListener(mouse.click, clickFunc, false);
    if (touchFunc) {
        elm.addEventListener(touch.start, touchFunc, { passive:true });
        elm.addEventListener(touch.end,   touchFunc, false);
    }
}
function removeMouseTouch(elm, mouseFunc, clickFunc, touchFunc) {
    if (mouseFunc) {
        elm.removeEventListener(mouse.enter, mouseFunc, false);
        elm.removeEventListener(mouse.leave, mouseFunc, false);
        elm.removeEventListener(mouse.down,  mouseFunc, false);
        elm.removeEventListener(mouse.up,    mouseFunc, false);
    }
    if (clickFunc)
        elm.removeEventListener(mouse.click, clickFunc, false);
    if (touchFunc) {
        elm.removeEventListener(touch.start, touchFunc, false);
        elm.removeEventListener(touch.end,   touchFunc, false);
    }
}
////////////////////////////////////////////////////////////////////////////////
// non-click mouse events
function mouseIt(evt) {
    let elm, f, id, m, n, s, tar;
    tar = evt.target;
    id  = tar.id;
    f   = stdDev / 3;
    if (id) {
        m = (id == "mute");
        s = (id == "spelunk");
        switch (evt.type) {
        case mouse.out:
        case mouse.leave:
            n = stdDev - (m ? f : 0);
            break;
        case mouse.over:
        case mouse.enter:
        case mouse.up:
            n = (s ? 0 : f);
            break;
        case mouse.down:
            n = stdDev - (m ? stdDev / 2 : f);
        }
        if (s)
            n += stdDev;
        else if (id == "agree")
            n += (stdDev / 3);

        elm = (butts[id] ? butts[id].blur : songs[AT.di.getn(tar)].blur);
        AT.sD.set(elm, n);
    }
    else { // unreleased songs in songMenu
        switch (evt.type) {
        case mouse.out:
        case mouse.leave:
            n = AT.di.getn(tar);
            tar.nextElementSibling.textContent = songs[n].title;
            break;
        case mouse.over:
        case mouse.enter:
            n = Math.ceil((song.next - Date.now()) / msecs);
            tar.nextElementSibling.textContent = leadingZero(n) + " days to go...";
            break;
        default:
        }
    }
}
////////////////////////////////////////////////////////////////////////////////
// mouse click event
function clickIt(evt) {
    let id;
    if (evt.target) {
        evt.stopPropagation();                  // clickWindow() not called
        id = evt.target.id;
    }
    else
        id = evt;                               // postBeam() passes id as evt
    ////////////////////////////////////////////
    if (id.substring(id.length - 1) == "_") { ///\ song in songMenu
        song.select(evt.target);
        song.close();
    }
    else if (prefix(id) == ids.song) {        ///\ songButt
        if (!closeMenus())                      // returns true if songMenu was
            song.open();                        // open, and is now closing.
    }
    else if (id == "spelunk") {               ///\ spelunker button
        window.location.href = window.location.origin + "/SMAWS/Spelunker.html";
    }
    else if (id == "mute")                    ///\ mute button
        muteIt();
    else if (suffix(id) != ids.butt)          ///\ faq, fuq, bio, smaws
        window.location.href = window.location.origin + "/" + id + ".html";
    else {
        let elm, menu, r;                     ///\ share, download, stream Butts
        elm  = beam.elms[0];
        menu = menus[prefix(id)];
        if (song.isOpen)                        // close song/open menu can be
            closeMenus();                       // simultaneous
        else if (elm) {                         // close/open menu is sequential
            if (menu !== elm)
                beam.next = id;                 // postBeam() calls clickIt(id)
            closeMenus();                       // after beam.target has closed
            return;
        }
        beam.elms[0] = menu;                    // direct setting of elements ok
        beam.next = null;                       // because easer.type == null.

        r = butts[id].rect.getBoundingClientRect();
        menu.style.top  = (r.bottom + 2 - menu.offsetHeight) + U.px; //!!literal
        menu.style.left = (r.right  + 9) + U.px;                     //!!literal
        beam.svg.style.top  = menu.style.top;
        beam.svg.style.left = menu.style.left;
        sizeSvg(beam.svg, menu.offsetWidth, menu.offsetHeight);

        if (id =="shareButt") {
            if (!share) {
                alert("Still waiting for share.txt to load. Please try again in a few seconds.");
                return;
            }
            if (menu.innerHTML == "") {
                menu.innerHTML = share;
                // Google
                script("https://apis.google.com/js/platform.js",   false, true, true);
                // Pinterest
                script(      "//assets.pinterest.com/js/pinit.js", false, true, true);
                // Twitter
                script("https://platform.twitter.com/widgets.js",  false, true);
                // Facebook
                script(false, "(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(d.getElementById(id))return;js=d.createElement(s);js.id=id;js.src='https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v3.0';fjs.parentNode.insertBefore(js, fjs);}(document,'script','facebook-jssdk'));");
                // Tumblr
                script(false, "!function(d,s,id){var js,ajs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src='https://assets.tumblr.com/share-button.js';ajs.parentNode.insertBefore(js,ajs);}}(document,'script','tumblr-js');");
            }
            else { // yes, it runs every time, but it's inexpensive
                menu.style.width     = "";
                menu.style.minHeight = "";
            }
        }
        beamMe(true);
    }
}
////////////////////////////////////////////////////////////////////////////////
// touch events
function touchIt(evt) {
}
////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Other global functions /////////////////
////////////////////////////////////////////////////////////////////////////////
// called by setInterval()
function grainy() {   // changes the grain of #static for pre-agree bg <rect>
    if (glob.seed) {
        AT.seed.set(grain, Math.random() * glob.seed);
        if (glob.seed < seedy)
            --glob.seed;        // eventually calls clearInterval() below
    }
    else
        clearInterval(glob.val); // this is a key feature of animateGrain()
}
function staticky() { // changes the grain of #static for the beam/transporter
    AT.seed.set(grain, Math.random() * beam.seed);
}
////////////////////////////////////////////////////////////////////////////////
// File loading functions
function loadSample(obj, name, prop) {
    let request = new XMLHttpRequest();
    request.onload = function() {
        ctx.decodeAudioData(request.response, function(buffer) {
            obj[prop] = buffer;
            if (glob)
                glob.count += (obj === keys);
        }, function(a) {
            console.log("Audio error! ", a, name);
        });
    };
    request.open("GET", "samples/" + name + ".mp3", true);
    request.responseType = "arraybuffer";
    request.send(); // send the request, which calls request.onLoad()
}
function getShare() {
    let r = new XMLHttpRequest();
    r.overrideMimeType("text/plain");
    r.addEventListener("readystatechange", onReadyState, false);
    r.open("GET", "share.txt", true);
    r.send();
}
function onReadyState(evt) {
    let xhr = evt.target;
    if (xhr.readyState == 4) { // 4 == DONE, status == success|failure
        if (xhr.status != 200 && xhr.status != 304)
            alert("The share.txt file failed to load!");
        else
            share = xhr.responseText;
    }
}
function script(src, text, async, defer) {
    let elm = document.createElement("script");

    if (async)
        elm.async = async;
    if (defer)
        elm.defer = defer;
    if (src)
        elm.src   = src;
    else if (text)
        elm.text  = text;

    beam.elms[0].appendChild(elm);
}
////////////////////////////////////////////////////////////////////////////////
// Assorted functions, generalized stuff
function prefix(str) {            // "Menu" and "Butt" are both 4 characters
    return str.substr(0, str.length - 4);
}
function suffix(str) {
    return str.substr(str.length - 4);
}

// Converts a number to text w/leading zero(s)
function leadingZero(n, digits = 2) {
    let txt = "";
    let max = Math.pow(10, --digits);
    while (n < max && digits-- > 0) {
        txt += "0";
        max /= 10;
    }
    txt += n;
    return txt;
}

// Creates a buffer source, sets its buffer and connects it to a destination
function cBufSrc(buf, dest) {
    let bs    = ctx.createBufferSource();
    bs.buffer = buf;
    bs.connect(dest);
    return bs;
}
function isMuted() {                 // mute button get and set functions
    return(butts["mute"].on);
}
function muteIt(m = !isMuted()) {
    if (m) {
        AT.href.set(butts.mute.use, "#Hi");
        butts.mute.on = true;
        vol  .gain.setValueAtTime(0, 0);
        noise.gain.setValueAtTime(0, 0);
    }
    else {
        AT.href.set(butts.mute.use, "#No");
        butts.mute.on = false;
        vol  .gain.setValueAtTime(0.1, 0);
        noise.gain.setValueAtTime(0.1, 0);
        vol  .gain.exponentialRampToValueAtTime(0.8, ctx.currentTime + 0.25);
        noise.gain.exponentialRampToValueAtTime(0.4, ctx.currentTime + 0.25);
    }
    localStorage.setItem("muteHome", m ? "Y" : "");
}
////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// window event handling: click, resize ///
////////////////////////////////////////////////////////////////////////////////
// window.onclick
function clickWindow(evt) { // songMenu has inner and outer children w/o id
    if (suffix(evt.target.id || evt.target.parentNode.id) != ids.menu)
        closeMenus();
}
function closeMenus() {
    if (song.isOpen) {
        song.close();
        return true;
    }
    else if (beam.elms[0])
        beamMe(false);
}
////////////////////////////////////////////////////////////////////////////////
// Window resize event handler and friends, throttled via: RAF.func = reWind;
// resizeWindow()   is the event handler
// reWind()         is the RAF.animate() callback
// sizeOn()         turns on  the event listener during pauses in animation
// sizeOff()        turns off the event listener during some animations
// windowResize()   does all the work, returns true for RAF.animate()
function resizeWindow(evt) { RAF.start(); }
function reWind() {
    if (mcW != main.clientWidth || mcH != main.clientHeight)
        return windowResize();
}
function sizeOn()  { window   .addEventListener("resize", resizeWindow, false);}
function sizeOff() { window.removeEventListener("resize", resizeWindow, false);}
function windowResize() {

    mcW = main.clientWidth;
    mcH = main.clientHeight;
    adjustBg();
    if (!hasAgreed)
        sizeAgree();
    return true;                     // tells RAF to loop one more time
}
function adjustBg() {                // #bg needs adjusting when window resizes
    AT.w.set(bg.svg, mcW);
//    AT.h.set(bg.svg, mcH);
    AT.tSVG.let(bg.astro, mcH, EZ.y, FN.r);
    adjustWeave();
}
function adjustWeave() {             // the #cloth filter is affected by size
    let f;                           // this maintains the visual constant
    if (mcW / vb[2] > mcH / vb[3])
        f = mcH;
    else if (hasAgreed)
        f = mcW / asp;
    else
        f = svg.clientHeight * (vbC[3] / vb[3]);

    f *= (shirt.bF / 1080);
    AT.bF.set(shirt.elm, f);
//    console.log("weave:" + f);
}
function sizeSvg(elm, w, h) {        // sizes the svg and it's children
    let kids = elm.children;         // for #bg and #beam

    AT.vB.set(elm, [0, 0, w, h]);
    AT.w .set(elm, w);
    AT.h .set(elm, h);

    for (const kid of kids) {
        AT.w.set(kid, w);
        AT.h.set(kid, h);
    }
}
// Pre-agreement sizing ////////////////////////////////////////////////////
function sizeTerms(elm) {
    if (typist.last) return;         // during fadeUp() only

    glob.divH.addend = mcH - svg.clientHeight;
    glob.divH.factor = glob.height - glob.divH.addend;
    if (glob.divH.factor > 0)
        AT.h.set(elm, glob.divH.addend);
    else {
        glob.divMT.factor = glob.divH.addend - elm.clientHeight;
        AT.mT.set(elm, glob.divMT.factor);
    }

    glob.zoom  = glob.svgH  / vb[3];
    glob.offZ  = glob.offW  * glob.zoom;

    glob.svgW.addend = glob.offZ;
    glob.svgW.factor = glob.vbW * glob.zoom;
    glob.svgW.max    = glob.width;

    typist.svgW.addend = glob.svgW.factor;
    typist.svgW.factor =-glob.svgW.factor;
    typist.svgW.max    = glob.width;

    typist.svgH.addend = typist.height; //!!
    typist.svgH.factor = glob.svgH - typist.height;

}
function sizeAgree() {
    let H, isH, n, svH, W;
    AT.flex.cut(svg);
    AT.w   .cut(div);                // <style>#terms{width:100%}</style>
    AT.aS  .cut(typist.div);
    AT.oY  .set(main, "hidden");
    svH = mcW / asp;
    isH = mcH - svH < div.clientHeight && mcW > mcH;
    if (isH) {                       // svg is height-constrained, landscape
        if (!typist.spans)
            AT.h.cut(svg);
        H = mcH * 0.5;               // svg min height
        W = mcW * 0.33;              // min-width
        if (H * glob.asp > W)        // biggest one wins
            W = false;
        else
            H = false;

        svH = false;
        do {
            n = Math.floor((mcH - div.clientHeight) * glob.asp);
            if (W && n <= W)  {      // enforce min-width
                n   = W;
                svH = W / glob.asp;  // glob.asp converts #terms to svg scale
            }
            div.style.width = n + U.px;
            if (H) {
                n = div.clientHeight;
                if (mcH - n <= H) {  // enforce svg min-height
                    div.style.width = Math.floor(H * glob.asp) + U.px;
                    svH = H;
                }
            }
            if (svH) {
                AT.oY.set(main, "scroll");
                mcW = main.clientWidth;
                if (!typist.spans) {
                    AT.h.set(svg, svH);
                    svg.style.flex = "0 0 auto";
                }
                break;
            }
        } while (Math.floor((mcH - n) * glob.asp) < div.clientWidth);

        if (glob.p.clientHeight == glob.plH)
            div.style.width = "auto";
        if (typist.spans) {          // before/during fadeUp()
            H = svH || mcH - div.clientHeight;
            glob.width = H * asp;
            svg.style.marginLeft   = ((mcW - glob.width) / 2) + U.px;
            typist.div.style.width = glob.width + U.px;
        }
    }
    else {                           // svg is width-constrained or portrait
        if (typist.spans) {          // before/during fadeUp()
            if (svH + div.clientHeight > mcH) {
                AT.oY.set(main, "scroll");
                typist.div.style.width = mcW + U.px;       //!!100% includes scrollbar!!
                typist.div.style.alignSelf = "flex-start"; //!!align-self:stretch doesn't always stretch
            }
            else
                typist.div.style.width = "100%";

            glob.width = mcW;
            H = vb[3] * (glob.width / vb[2]);
            svg.style.marginLeft = "";
        }
        else {
            AT.h.cut(svg);
            if (svg.clientHeight + div.clientHeight > mcH)
                AT.oY.set(main, "scroll");
        }
    }
    if (typist.spans) {              // before or during fadeUp()
        glob.svgH     = H;
        typist.height = typist.vb[3] * (glob.width / typist.vb[2]);
        AT.h.set(svg, H);
        AT.h.set(typist.svg, typist.height);
        AT.h.set(glob.wipe.parentNode, H);
        sizeTerms(div);
        svg.style.flex = "0 0 auto";
        Attr.visible(glob.dark.children[0],  isH);
        Attr.visible(glob.dark.children[1], !isH);
        glob.height = div.clientHeight; // target div height
    }
}
////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Home Page Animations ///////////////////
////////////////////////////////////////////////////////////////////////////////
// #transporter (beam) and ids.menu (excluding songMenu) animation functions
function initBeam(id, elms, func, beamer, beamee, ex, idEx) {
    let ez;
    if (!beam.eases) {
        let m = defs.getElementById("matrix");
        AT.type.set(m, "matrix");               // #static filter green-only
        AT.values.set(m, "0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0");
        AT.bF.set(grain, "0.3, 0.3");           // bigger looks better here,
        beam.k3 = 0.8;                          // less gpu usage is a bonus.
        AT.k3.set(comp, beam.k3);               // brighter too, via k3.
        beam.seed  = seedy;
        beam.eases = new Array(3);
    }
    ez = Easy.create(beamer);                   // the beamer (static/grain)
    ez.addBy(AT.k3, comp, beam.k3, beam.k3);
    beam.opct = ez.addBy(AT.o, id, 0.3);
    beam.svg  = beam.opct.elms[0];              // .svg only used by #beam
    beam.eases[0] = ez;

    ez = Easy.create(beamee);                   // beamee = beamed object
    beam.target = ez.addBy(AT.o, elms);         // elms arg can be id or element
    beam.elms   = beam.target.elms;
    beam.target = beam.target.easee;            // one case of target = easee
    beam.eases[1] = ez;

    if (ex) {                                   // ex for extra or extended
        ez = Easy.create(ex);                   // an extra element of static
        ez.addBy(AT.o, idEx);                   // for beaming up it's outro
        beam.eases[2] = ez;                     //           down it's intro
    }
    else
        beam.eases.length = 2;

    Easy.last(beam.eases).post = func;          // the longest lasting ez
}
function beamMe(up) {            // for menus and #beam, not #transporter
    beam.val = setInterval(staticky, fps);
    beam.target.is1m = !up;
    beam.eases.forEach((ez) => {
        ez.reuse();
        RAF.eases.push(ez);
    });
    RAF.start();
}
function postBeam() {            // for menus and #beam, not #transporter
    clearInterval(beam.val);     // stop staticky()
    if (beam.target.is1m)
        beam.elms[0] = null;
    if (beam.next)               // we just closed a menu, now open
        clickIt(beam.next);      // another one: beam.next
}
//////////////////////////////////////// Pre-agreement animations //////////
function initWelcome() {
    let elm, ez, i, j, k, l, m, oR, oT, t, tester, w, welt;
    const up = -33;

    glob = Object.create(null);              // factotem object
    glob.count =  0;                         // global count: samples loaded
    glob.randy = 16;                         // # of samples for random play
    glob.endl  = glob.randy + 1;             // index of endl sample
    glob.load  = glob.randy + 2;             // total # of samples to load
    keys = new Array(glob.load);             // keyclick samples by index
    nbsp = glob.randy;                       // penultimate sample in array
    for (i = 0; i < glob.randy; i++)         // loadSample() {glob.count++;}
        loadSample(keys, "key" + i, i);
    loadSample(keys, "space", nbsp);
    loadSample(keys, "endl",  glob.endl);

    vb = AT.vB.getn(svg);                    // must precede windowResize()
    glob.asp  = (vb[2] - oneX) / vb[3];      // #terms is oneX thinner
    glob.wipe = document.getElementById("wipe");
    glob.seed = seedy;                       // random number range for seed
    glob.val  = setInterval(grainy, fps);    // launch the grain randomizer
    glob.dark = svg.getElementById("dark");  // must precede windowResize()
    Attr.visible(glob.dark, true);

    AT.jC.set(main, "normal");
    div = document.getElementById("terms");
    AT.display .cut(div);                    // defaults to display:none;
    AT.position.set(div, "absolute");        // starts off-screen
    k = div.children;
    glob.p = k[0];                           // windowResize() uses p, plH
    for (i of k) {                           // longest <p>, does it wrap?
        if (i.textContent.length > glob.p.textContent.length)
            glob.p = i;
    }
    glob.plH = i.clientHeight;               // <p> line height

    glob.vbH =  320;      // middle of pre-agree animation viewBox height value
    typist = Object.create(null);            // animated text object
    typist.svg = document.getElementById("typist");

    t  = 1500;                               // Fade In & Test Animations //
    ez = RAF.add({mid:400, time:t, pause:100});
    ez.addBy(AT.k3, comp, 0.8, null);
    ez.add({attr:AT.o, elm:bg.static,                 leg:E.outward});
    ez.add({attr:AT.o, elm:typist.svg, oneMinus:true, leg:E.return });
    tester = ez;

    w  = t;                                  // if (!gpu) fade out static
    t  = 400;
    ez = RAF.add({wait:w,  time:t, gpu:0});
    ez.add({attr:AT.o, elm:bg.static, oneMinus:true});

    welt = 4000;                             // welt = welcome time
    w = initYesNo(t + w + t, w, welt);       // YesNo   Animation //
                                             // Welcome Animation //
    ez = RAF.add({wait:w, time:welt, pre:preWelcome, post:postWelcome});
    elm = defs.firstElementChild.lastElementChild;
    ez.addBy(AT.x1, elm, 1, -1);             // gradient x1, x2
    ez.addBy(AT.x2, elm, 1,  1);             // asterisk rotation
    ez.add({attr:AT.tSVG, elms:typist.rotateL, func:FN.r, factor:-720});
    ez.add({attr:AT.tSVG, elms:typist.rotateR, func:FN.r, factor: 720});
                                             // text opacity and risks color
    ez = RAF.add({wait:w, time:welt, mid:400, pause:welt - 1200});
    ez.add({attr:AT.f,    elms:typist.risks, factor:255, mask:EZ.R + EZ.B});
    ez.add({attr:AT.o,    elms:typist.rainbow,  leg:E.outward});
    ez.add({attr:AT.o,    elms:typist.welcome,  leg:E.return});
    ez.add({attr:AT.o,    elms:typist.prompt,  is1m:true});
                                             // <tspan> symbols float up
    ez = RAF.add({wait:w,       time:1000, byElm:true, end:up});
    ez.add({attr:AT.y,    elms:typist.chars.slice(3, 5), addend:null});
    ez = RAF.add({wait:w + 300, time: 500, byElm:true, end:up});
    ez.add({attr:AT.y,    elms:typist.chars.slice(0, 3), addend:null});
    ez = RAF.add({wait:w + 600, time: 500, byElm:true, end:up});
    ez.add({attr:AT.y,    elms:typist.chars.slice(6, 9), addend:null});

    t  = w + 500;
    m  = 700;                                // smileys float up and wobble
    oT = {attr:AT.tSVG, func:FN.t, mask:EZ.y, addend:0, set:E.set};
    oR = {attr:AT.tSVG, func:FN.r};
    for (i = 0, j = 1; i < 3; i++, j++) {
        k = (i * m) + t;
        l = (j * m) - (i * 180);

        ez = RAF.add({wait:k, time:l, end:up * j});
        oT.elms = typist["smile" + j];
        ez.add(oT);

        ez = RAF.add({wait:k, time:l, mid:Math.floor(l / 3), end:-10, end2:12});
        oR.elms = Array.from(oT.elms.children);
        ez.add(oR)
    }
                                             // blue to white, asters/skull up
    ez = RAF.add({wait:w + welt - 2100, time:1900});
    ez.add({attr:AT.f,    elms:[...typist.asters, ...oR.elms],
                                        factor:255,  mask:EZ.R + EZ.G});
    ez.add({attr:AT.tSVG, elms:typist.up, func:FN.t, mask:EZ.y, set:E.set,
                                        factor:up, addend:0});
    return tester;
}
function preWelcome() {
    Attr.visible(typist.cursor, false);
}
function postWelcome() {
    AT.tSVG.cut(typist.risks[0]);
    AT.tSVG.cut(typist.risks[1]);
    typist.risks[0].style.fill  = "";
    typist.risks[1].style.fill  = "";
    typist.welcomed = true;
}
function setupSpan(span, idx, pos) { // helper for initYesNo() and initLogo()
    AT.dy.set(span, "1em");          // pos defined when called by clickYesNo()
    if (pos)                         // logo   == text-anchor:middle
        AT.x.set(span, pos);
    else                             // typist == text-anchor:start
        AT.x.set(span, idx == 0 ? typist.twoX : oneX + typist.offX);
}
function initYesNo(t, w, welt) {     // makes loadIt() more readable
    let cues, i, j, k, kids, l, line, obj, span;
    l = yesNo.length;
    typist.offX  = 0.25;   // offset for text in order to center properly
    typist.twoX  = (oneX * 2) + typist.offX;
    typist.x     = typist.twoX;      // implied initial cmd prompt
    typist.y     = oneY;
    typist.vb    = AT.vB.getn(typist.svg);
    typist.div   = typist.svg.parentNode;
    typist.last  = l - 1;
    typist.line  = 0;                // current line/span index
    typist.spans = new Array(l);     // array of tspans
    typist.yline = butts["yes"].rect.nextElementSibling;
    typist.nline = butts["no" ].rect.nextElementSibling;
    typist.tick4 = tick * 4;
    typist.tick8 = tick * 8;

    kids = Array.from(typist.svg.children);
    k    = 0;
    typist.text    = kids[0];
    typist.cursor  = kids[1];
    typist.prompt  = kids[2];
    typist.rainbow = kids[3];
    typist.risks   = kids.slice(4, 6);
    typist.risk    = 0;              // two asterisks that rotate and an index
    kids = typist.rainbow.children;
    typist.smile1  = kids[0]; //Array.from(kids[0].children);
    typist.smile2  = kids[1]; //Array.from(kids[1].children);
    typist.smile3  = kids[2]; //Array.from(kids[2].children);
    typist.chars   = Array.from(kids[3].children);
    typist.welcome = kids[4];
    typist.asters  = Array.from(kids[5].children);
    typist.rotateL = [typist.risks[0], typist.asters[0]];
    typist.rotateR = [typist.risks[1], typist.asters[1]];
    typist.up      = [kids[3], kids[5]];

    cues = RAF.cue(cueYesNo);
    for (i = 0; i < l; i++) {
        span = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        setupSpan(span, i);
        typist.spans[i] = span;
        typist.text.appendChild(span);

        line = yesNo[i];             // yesNo array is text source
        for (j = 0; j < line.length; j++) {
            obj = cues.push(t);
            obj.char = line.substr(j, 1);
            if (i == 2 && j == line.length - 1) {
                w = t + 250;         // after the welcome line there is an extra
                t = w + welt + 750;  // easing animation for the welcome text.
            }
            if (i > 0 && j == 0) {   // pause after newline means pause is start
                obj.endl = true;     // of next line.
                if (l == 3)
                    t += 500;        // extra pause after welcome new line
                if (obj.char == ">") // prompt at start of line
                    t += (typist.tick8);
                else                 // basic start of line
                    t += (typist.tick4);
            }
            else    t += tick;       // character within a line
        }
    }
    return w;
}
function cueYesNo(cue, ac) {         // run-time cue handler for yesNo "typist"
    if (ac.index == 0 && !RAF.gpu)
        glob.seed = 0;               // = clearInterval(glob.val) = no static

    if (cue.endl) {                  // start of new line
        typist.isYN = (++typist.line == typist.last);
        if (typist.welcomed) {       // must be in this frame, not postWelcome()
            Attr.visible(typist.cursor, true);
            delete typist.welcomed;
        }
        typist.x  = typist.twoX;     // carriage return + line feed
        typist.y += oneY;
        AT.y.set(typist.cursor, typist.y);
    }
    else
        typist.x += oneX;
                                     // move the cursor and type the character
    AT.x.set(typist.cursor, typist.x);
    if (cue.char != "*")
        typist.spans[typist.line].textContent += cue.char;
    else {                           // rotating chars are separate elements
        typist.spans[typist.line].textContent += E.sp;
        Attr.visible(typist.risks[typist.risk++], true);
    }

    if (typist.isYN) {                 // YES NO <text>s have uline rects
        const x = (typist.x - typist.offX) / oneX ;
        let   b = false;
        if (x > 6 && x < 10)           // YES rect is 2px shorter than normal
            AT.w.set(typist.yline, ((x - 6) * oneX) - 2);
        else if (x > 12 && x < 15)
            AT.w.set(typist.nline, (x - 12) * oneX);
        else
            b = true
        Attr.visible(typist.cursor, b);
    }

    if (ac.index == ac.last) {       // last cue
        Attr.visible(typist.cursor, false);
        let y = butts["yes"].rect;
        let n = butts["no" ].rect;   // swap in texts for tspans: Firefox
        Attr.visible(y.previousElementSibling, true);
        Attr.visible(n.previousElementSibling, true);
        typist.spans[typist.line].textContent = "";
        typist.yn = y.parentNode;    // for clickYesNo()
                                     // events use filters: Ffx != tspan filter
        addMouseTouch(y, mouseIt, clickYesNo, touchIt);
        addMouseTouch(n, mouseIt, clickYesNo, touchIt);
        sizeOn();
    }
}
function clickYesNo(evt) {
    let bord, ez, fL, fR, s, t, w;
    sizeOff();
    removeMouseTouch(butts["yes"].rect, mouseIt, clickYesNo, touchIt);
    removeMouseTouch(butts["no" ].rect, mouseIt, clickYesNo, touchIt);
    AT.sD.set(butts[evt.target.id].blur, stdDev);
    AT.pE.set(main, "auto");         // the only way scroll bars work, doesn't
                                     // affect the I Agree button.
    if (evt.target.id == "no") {     // audio: yes or no?
        audio = false;
        muteIt(true);
    }
    else {
        audio = true;
        ctx.resume();
        if (RAF.gpu && fx[stat]) {   // only if sample loaded
            s = cBufSrc(fx[stat], noise);
            s.loop      = true;
            s.loopStart = 0.1;
            s.loopEnd   = s.buffer.duration - 0.1;
            s.start();
            src[stat] = s;
            noise.gain.setValueAtTime(0.1, 0);
            noise.gain.exponentialRampToValueAtTime(0.75, ctx.currentTime + 1);
        }
    }                                // visuals: set up the animations
    typist.x = (oneX *  2) + typist.offX;
    AT.x.set(typist.cursor, typist.x);
    AT.y.set(typist.cursor, oneY);   // position the cursor, set its
    AT.o.set(typist.cursor, 0);      // opacity = 0 & visible = true
    Attr.visible(typist.cursor, true);

    bord = body.get(ids.bord);       // get the border width
    glob.bordX = AT.x.getn(bord);    // then set the border width to zero
    glob.bordW = AT.w.getn(bord);    // must precede next line
    AT.w.set(bord, 0);
    AT.o.set(bord, 1);
                                     // these are opacity-fading masks
    glob.fadeL = defs.getElementById("fadeL").children;
    glob.fadeR = defs.getElementById("fadeR").children;
    glob.offs  = 0.03;               // 3% of the text/border width * 2 sides,
    glob.offW  = glob.offs * vb[2];  // left and right.
    glob.vbW   = vb[2] + glob.offW;

    t  = 1000;                       // fade out all but cursor
    ez = RAF.add({time:t, type:E.out, pow:2, post:postFadeOut})
    ez.add1m(AT.o, [typist.text, typist.yn, ...typist.risks]);
    ez.addBy(AT.o, typist.cursor);   // cursor fades in

    w  = initLogo(t)
    t  = 3000;                       // this "wipe" Easy has 12 targets
    ez = RAF.add({wait:w, time:t, pow:(RAF.gpu ? 1.67 : 1), pre:preWipe,
                                                           post:postWipe});
    ez.addBy(AT.o, div);             // -0.75 centers the 1.5px wide wiper
    ez.add({attr:AT.x,  elm:glob.wipe, factor:glob.vbW, addend:vb[0] - 0.75});
    ez.add({attr:AT.w,  elm:bord,      factor:glob.vbW, addend:-glob.bordX,
                                          min:0,           max: glob.bordW});
    ez.add({attr:AT.vB, elm:typist.svg,  mask:EZ.x + EZ.w,
          factor:[glob.vbW,                 vb[2] - typist.vb[2]],
          addend:[typist.vb[0] - glob.offW, typist.vb[2]],
             min:[typist.vb[0],            -Infinity],
            plug:[typist.vb[1], typist.vb[3]]});

    fL = defs.getElementById("fadeL").children;
    fR = defs.getElementById("fadeR").children;
    ez.add({attr:AT.offset, elm:[fL[2], fR[1]]});
    ez.add({attr:AT.offset, elm:fL[1], addend:-glob.offs});
    ez.add({attr:AT.offset, elm:fR[2], addend: glob.offs});

    // these factors, addends (and 1st two max values) are set by windowResize()
    // factor:2 != 1 or 0, so easer.computer is correctly set by ez.add()
    glob  .svgW  = ez.add({attr:AT.w,  elm:svg,        factor:2, addend:0, min:0});
    typist.svgW  = ez.add({attr:AT.w,  elm:typist.svg, factor:2, addend:0, min:0});
    typist.svgH  = ez.add({attr:AT.h,  elm:typist.svg, factor:2, addend:0});
    glob  .divH  = ez.add({attr:AT.h,  elm:div,        factor:2, addend:0,
                           eval:evalTerms});
    glob  .divMT = ez.add({attr:AT.mT, elm:div,        factor:2, addend:0,
                           eval:evalTerms, value:false,        oneMinus:true});
    if (RAF.gpu) {
        w += t;                      // dark fades from current value to 0
        t  = 8000;
        ez = RAF.add({wait:w, time:t});
        ez.add({attr:AT.o, elm:glob.dark, factor:null, addend:0, oneMinus:true});

        glob.pow = 5.5;              // grain drips down y axis
        w += t;
        t  = 17000;
        ez = RAF.add({wait:w, time:t, type:E.out, pow:glob.pow, pre:preGrain});
        glob.grain = {attr:AT.bF, elm:grain, mask:EZ.y, end:0.00002};
        ez.add(glob.grain);          // glob.grain is reused in iAgree()

        if (src[stat]) {
            t += w
            s  = ctx.currentTime + (t / 1000);
            setTimeout(changeRG, w + 1000, s - 2, s - 9);
            setTimeout(fadeGain, t - 6000, s);
            ez.post = postGrain;
        }
    }
    RAF.start();
}
function postFadeOut() {             // restoring opacity can't be in cueLogo
    AT.o.set(typist.text, 1);        // because final ease() after first cueLogo
}                                    // if (next start == end) animations ellide
function initLogo(t) {                     // sets up the logo <text>
    let c, cues, i, j, line, min, obj, span, vari;
    const amp = "&";
    const x   = vb[2] / 2 + vb[0] - 1.25;  // x-coord, text-anchor:middle

    logo = Array.from(body.get(ids.logo).children);
    const l    = logo.length;
    const full = logo[l - 2].textContent.length + 1; // tspan is full width

    if (t) {                               // t only defined if (!hasAgreed)
        typist.line = 0;
        typist.y = oneY;
        cues = RAF.cue(cueLogo);
        min  = tick + 35;                  // minimum extra for non-spaces
        vari = tick - 35;                  // the leftover variable range
        glob.prompt = svg.getElementById("prompt");
        Attr.visible(glob.prompt, true);
    }
    else
        AT.mask.cut(body.get(ids.logo));

    for (i = 0; i < l; i++) {
        span = logo[i];
        setupSpan(span, i, x);
        if (t) {                           // typist cues, pre-agreement
            line = span.innerHTML;
            for (j = 0; j < line.length; j++) {
                obj = cues.push(t);
                obj.char = line.substr(j, 1);
                if (obj.char == amp) {
                    c = line.indexOf(";", j) - j + 1;
                    obj.char = line.substr(j, c);
                }
                switch(line[j]) {
                case E.sp:
                    if (i > 0 && j == 0) {
                        obj.key = glob.endl;
                        t += typist.tick4; // start of line acts as endl for
                    }                      // previous line; lines start with
                    else {                 // E.sp or &gt (>command prompt).
                        obj.key = nbsp;    // new line w/E.sp pauses 4 ticks
                        t += tick;         // else E.sp pauses only  1 tick
                    }
                    break;
                case amp:
                    j += --c ;
                    if (i > 0 && j == c) { // j was 0: "&gt;" == cmd prompt
                        obj.key = glob.endl;
                        t += typist.tick8; // new line w/&gt; pauses 8 ticks
                        continue;
                    }                      /* falls through */ // fall-through
                default:                   // everything else is pseudo-random
                    obj.key  = Math.floor(Math.random() * glob.randy);
                    t += min + Math.floor(Math.random() * vari);
                }
            }                              // end for (j)
        }                                  // end if (t)
        if (i == 0)                        // left pad it with a space
            span.innerHTML = E.sp + span.innerHTML;
        j = span.textContent.length;
        if (j < full)                      // right pad it with spaces
            span.innerHTML += new Array(full - j).join(E.sp);
    }                                      // end for (i)
    return t;                              // return the accumulated time
}
//function initAsterisks() {                 // vertically align asterisks
//    const dy1 = "1em,0,0,0,0,0,0,0,0,0.085em,0,0,-0.085em";
//    AT.dy.set(logo[1], dy1);
//    if (!hasAgreed)
//        AT.dy.set(typist.spans[1], dy1);
//}
function cueLogo(cue, ac) {          // cues precede eases in RAF.animate()
    if (ac.index == 0) {
//        initAsterisks();           // clear the tspans can't be in postFadeOut
        typist.spans.forEach((v, i, a) => { a[i].textContent = ""; });
        noise.gain.exponentialRampToValueAtTime(0.5, ctx.currentTime + 1);
    }
    if (cue.key == glob.endl) {      // start of new line
        typist.line++;
        typist.y += oneY;
        AT.y.set(typist.cursor, typist.y);
        typist.x  = oneX + typist.offX;
    }
    typist.x += oneX;
    AT.x.set(typist.cursor, typist.x);
    typist.spans[typist.line].innerHTML += cue.char;

    if (audio && glob.count == glob.load)
        cBufSrc(keys[cue.key], vol).start();
}
function evalTerms() { return glob.divH.factor > 0; }
function preWipe() {
    Attr.visible(glob.wipe,     true);
    Attr.visible(typist.cursor, false);
    delete typist.last;              // must precede sizeTerms()
    sizeTerms(div);
    div.style.position = "";
    if (audio && fx[neon]) {
        src[neon] = cBufSrc(fx[neon], vol);
        if (!RAF.gpu)
            src[neon].playbackRate.setValueAtTime(0.8, 0);
        src[neon].start();
    }
}
function postWipe() {
    AT.h .set(div, "auto");
    AT.mT.cut(div)
    initSvg();
    Attr.visible(glob.wipe, false);
    glob.freq = AT.bF.getn(grain);
    addMouseTouch(document.getElementById("agree"), mouseIt, iAgree, touchIt);
    delete typist.spans;             // windowResize() uses typist.spans
    sizeOn();
    if (src[neon])
        src[neon].stop();
}
function preGrain() {
    glob.seed = 122;                 // ~4sec to zero @30fps
}
function postGrain() {
    noise.gain.setValueAtTime(0, 0);
    src[stat].stop();
}
////////////////////////////////////////////////////////////////////////////////
// These functions are called by setTimeout() when RAF.gpu == true
function changeRG(r, g) {                           // R = Rate, G = Gain
  src[stat].playbackRate
            .exponentialRampToValueAtTime(0.10, r); // runs from +1 to t - 1
  noise.gain.exponentialRampToValueAtTime(0.99, g); // runs from +1 to t - 8
}
function fadeGain(g) {
  noise.gain.exponentialRampToValueAtTime(0.02, g); // runs from t - 6 to t
}
////////////////////////////////////////////////////////////////////////////////
// The "I agree" button click handler
function iAgree() {
    let ez, h, mid, n, t, v, z;
    sizeOff();
    removeMouseTouch(document.getElementById("agree"), mouseIt, iAgree, touchIt);
    AT.h.set(div, div.clientHeight);
    getShare();                              // get this going sooner, not later
    glob.asp = vbC[2] / vbC[3];
    if (RAF.gpu) {
        ez = RAF.last.eases[RAF.last.eases.length - 1];
        if (RAF.cancel(true, true)) {        // animation running only if (gpu)
            if (src[stat])
                src[stat].stop();
            if (RAF.gpu) {
                if (glob.seed == seedy)      //!!test this again!!
                    glob.pow = 2;            // pow for revert frequency ease
                else {                       // this is an unusual use of ease()
                    let e = ez.ease(ez.now, ez.time, E.in, 2, 2, glob.pow - 2);
                    if (!e.status)           // start=2: <2 == no change visible
                        glob.pow = e.value;
                }
            }
        }                                    // revert to original frequency
        glob.grain.end = ez.targets[0].easer.addend[1];
        ez = RAF.push(0, 3000, E.in, glob.pow);
        ez.add(glob.grain);
    }
    t = 2500;                                // half of total duration
    h = svg.clientHeight;                    // current height
    z = h / vb[3];                           // current zoom factor
    v = glob.vbH * z;                        // hypthetical height at full vbH
    if (v > mcH) {
        n   = (mcH - h) / (v - h);           // vb[3] has farther to go
        mid = t * Math.pow(n, 2);
        glob.vb3 = true;
    }
    else if (v < mcH) {
        n   = (mcH - v) / (mcH - h);         // stretch
        mid = t - (t * n);
        glob.vb3 = false;
    }
    else                                     // sizes align perfectly...
        mid = t;                             // ...it will happen. //!!needs testing!!

    ez = RAF.add({time:t, post:halfTime});  //\ first half
    ez.add1m(AT.o, div);

    ez = RAF.push(0, mid);                  //\ first  quarter, AT.vB and AT.h
    v  = Math.min(mcH, v);
    z  = Math.min(glob.vbH, mcH / z);
    ez.addTo(AT.h, svg, v, h);
    ez.add({attr:AT.vB, mask:EZ.h, elm:svg, start:vb, end:z, plug:vb,
            peri:vbUpdate});

    ez = RAF.add({wait:mid, time:t - mid}); //\ second quarter, AT.vB or  AT.h
    ez.add1m(AT.o, glob.prompt);             // delayed start
    if (glob.vb3)                            // keep increasing vb[3]...
        ez.add({attr:AT.vB, mask:EZ.h, elm:svg, start:z, end:glob.vbH, peri:vbUpdate});
    else {                                   // ... or stretch height
        ez.addTo(AT.h, svg, mcH, v);
        Attr.set(AT.w, svg, "100%");
        AT.pAR.set(svg, "none");
    }

    initBody(t);                            //\ second half, full duration easy

    if (audio && fx[neon]) {
        glob.outro = (RAF.gpu ? 0.2 : 0.6);  // extra duration for sound
        vol.gain.setValueAtTime(0.2, 0);
        // add the event listeners
        vol.gain.exponentialRampToValueAtTime(0.6, ctx.currentTime + 1);
        v = cBufSrc(fx[neon], vol);
        v.playbackRate.setValueAtTime(0.2, 0);
        v.playbackRate.exponentialRampToValueAtTime(0.8, ctx.currentTime
                                                       + (t / 1000)
                                                       + glob.outro);
        v.start(0, 0.1);                     // 0.1 skips over sample's fade-in
        src[neon] = v;
    }
    localStorage.setItem("agreed", "Y");
    RAF.start();
}
// initBody() is used both hasAgreed and !hasAgreed
function initBody(t) {               // t only defined if called by iAgree()
    let elms, ez, i, j, k, l, r;
    const FS = -3;                   // FS is for font sizing

    if (t) {                         // called by iAgree()
        let vbStart = vb.slice();    // start points
        vbStart[3]  = glob.vbH;      // vbUpdate() runs every frame to update vb
        ez = RAF.add({wait:t, time:t, peri:adjustWeave, post:agreed});
        ez.add({attr:AT.vB, elm:svg, start:vbStart, end:vbC, peri:vbUpdate});
        ez.addBy(AT.o, [bg.astro, bg.wall, body.get(ids.body)]);
        if (!glob.vb3)
            ez.addTo(AT.h, svg, mcW / glob.asp, mcH);
    }
    else {                           // hasAgreed needs to set values, not ease,
        ez = RAF.push(false);        // ez.zero = false lets me reuse this code.
        body.forEach((elm) => { AT.o.set(elm, 0); });
    }
                                     // song title: font-size
    ez.addTo(AT.fS, song.text, song.oneY, oneY);
                                     // links
    elms = Array.from(svg.getElementsByClassName("link"));
    ez.addBy(AT.fS, elms, FS, oneY); // - <text>: font-size
    l = elms.length;                 // - .uline: x, width
    r = new Array(l);                //    r for <rect>
    for (i = 0; i < l; i++)
        r[i] = elms[i].nextElementSibling;
    ez.addBy(AT.x, r, [13.15859375, 6.15234375, -0.87890625, -7.91015625]);
    ez.addBy(AT.w, r, [-5.2734375, -5.2734375,  -5.2734375,  -8.7890625]);

    l = logo.length - 1;             // logo: font-size, x, dy
    for (j = -0.5, k = -0.25, i = l;  i >= 0;  i--, j -= 0.5, k -= 0.25) {
        ez.addBy(AT.fS, logo[i], j);
        ez.addBy(AT.x,  logo[i], k);
    }                                // logo[0] maintains dy="1em"
    ez.add({attr:AT.dy, factor:-0.1,  addend:1, elm:logo[1],       units:U.em});
    ez.add({attr:AT.dy, factor:-0.11, addend:1, elm:logo.slice(2), units:U.em});
                                     // controls:    translateY
    elms = Array.from(body.get(ids.ctrl).children).slice(1, 3);
    elms.push(logo[0].parentNode);   // logo parent: translateY
    ez.add({attr:AT.tSVG, func:FN.t, mask:EZ.y, elms:elms, factor:[4.5, 8, 21]});
                                     // border: A.h
    ez.addBy(AT.h, body.get(ids.bord), -2, 3);
                                     // border gradient: A.SC
    ez.addBy(AT.sc, Array.from(defs.getElementById("bord").children),
             [[-128, 51,-128]], [[255, 204, 255]], undefined, EZ.G, 0);
}
function vbUpdate(target) {          // runs every frame
    vb = target.number;              // updates global viewBox variable
}
function halfTime() {                // runs at mid-point of iAgree animation
    AT.jC.cut(main);
    if (!hasAgreed) {
        AT.display.set(div, "none");
        AT.w.cut(svg);
        asp = glob.asp;              // new target aspect ratio
        if (glob.vb3) {
            vb[3] = glob.vbH;
            AT.vB .set(svg, vb);     // set clean start state
            AT.h  .cut(svg);         // stretch still needs these
            AT.pAR.cut(svg);
        }
        adjustBg();
    }
}
////////////////////////////////////////////////////////////////////////////////
function agreed() {
    let ez, ezTx, cues, i, l, w;
    if (hasAgreed)
        clearInterval(beam.val);     // stop staticky()
    else {                           // virgin user
        if (RAF.gpu)
            clearInterval(glob.val); // stop grainy()
        if (audio) {
            nbsp = fx.length;
            fx.push(keys[nbsp]);     // good-bye to keys
        }
        if (!glob.vb3) {
            AT.h  .cut(svg);
            AT.pAR.cut(svg);
        }

        hasAgreed = true;
    }
    AT.oY.cut(main);
    AT.pE.set(main, "none");
    sizeOn();
    if (src[neon])
        src[neon].stop(ctx.currentTime + glob.outro);
                                     // init beam and songMenu before events
    initBeam("beam", "shareMenu", postBeam,
             {time:2000, type:E.in, pow:1, mid: 500, pause:750},
             {time:1200, type:E.in, pow:1, wait:500});
    beam.elms[0] = null;             // it's simpler when initialized w/elms
    beam.opct.factor = 0.6;          // more opacity for the beam (it was 0.3)

    song.animations = Object.create(null);
    song.animations.x = new Easy(0, 500);
    song.animations.o = new Easy(0, tick);
    song.animations.x.addBy(AT.tSVG, song.butt, 2, 0, FN.t, EZ.x);
    song.animations.o.addBy(AT.o,    menus.song);
    window.addEventListener(mouse.click, clickWindow, false);
    l = glows.length - 5;            // last four are pre-agree only
    for (i = 0; i < l; i++)          // fifth is not a button, it's the "s"
        addMouseTouch(butts[glows[i]].rect, mouseIt, clickIt, touchIt);

    idler = Object.create(null);     // idler animations
    idler.idx   = 0;                 // idlers are ordinal then random order
    idler.eases = new Map();
                                     // a multi-ease transform: FN.skewX + FN.t
    ez   = Easy.create({time:2000, mid:1000, pause:0, end:90});
    ezTx = Easy.create({time:15000, increment:-1});
    ez.add({attr:AT.tSVG, func:[FN.rotate, FN.t], elm:bg.astro,
                          mask:[EZ.deg, EZ.x], eases:[, ezTx]});
    idler.eases.set(FN.rotate, ez);
    idler.eases.set(FN.t,      ezTx);

    bg.k3 = [35, -2.5];              // translate(bg.x) is via astroX()
    ez = Easy.create({time:15000, pow:3, peri:astroX, post:reverse});
    ez.addBy(AT.k1, A.k1, 9);
    ez.addBy(AT.k2, A.k2, 9);
    ez.addBy(AT.k3, A.k3, bg.k3[0]);
    idler.eases.set(AT.x,  ez);

//    ez = Easy.create({time: 3000, post:reverse});
//    ez.addBy(AT.k1, A.k1, 9);
//    ez.addBy(AT.k2, A.k2, 9);
//    idler.eases.set(AT.k1, ez);

//    ez = Easy.create({time: 5000, post:postK3 });
//    ez.addBy(AT.k3, A.k3, bg.k3[0]);
//    idler.eases.set(AT.k3, ez);

    ez = Easy.create({time: 4000, post:reverse});
    ez.addTo(AT.o, A.o, 0, 1);
    idler.eases.set(AT.o,  ez);

    ez = Easy.create({time: 5000, post:reverse});
    ez.add({attr:AT.v, elm:A.v, end:[0, 0], mask:EZ.GR + EZ.AB});
    idler.eases.set(AT.v,  ez);
                                     // hand is the 3rd idler object
    hand = svg.getElementById("g-hand");
    ez = Easy.create({time:  900, post:insignia, mid:450});
    ez.add({attr:AT.tSVG, elm:hand,     factor:7, func:FN.r});
    ez.add({attr:AT.bF,   elm:A.bF + 0, factor:0.0002});
    idler.eases.set(hand,  ez);

    ez = Easy.create({time: 5000, post:reverse});
    ez.addTo(AT.bF, A.bF, 0.01);     // A.bf == id of the target element
    idler.eases.set(AT.bF, ez);

    ez = Easy.create({time: 5000, post:reverse});
    ez.addBy(AT.tSVG, bg.astro, -360, 0, FN.r);
    idler.eases.set(FN.r,  ez);

    ez = Easy.create({time: 2000, post:insignia});
    ez.addBy(AT.bF, shirt.elm, -0.1, shirt.bF); //!!@1080 height
    idler.eases.set(shirt, ez);

    ez = Easy.create({time: 1500, post:idle, mid:750});
    ez.addTo(AT.so, A.so, 1);
    ez.addBy(AT.sD, A.sD, -stdDev);
    idler.eases.set(AT.sD, ez);

    song.close(true);                // move the song button into position
    idle();                          // start the idler
}
////////////////////////////////////////////////////////////////////////////////
// idle animation callbacks
function astroX() {                  // 1px per frame == speed varies by Hz, meh.
    if (bg.x <= bg.lastX || bg.x >= 0)
        bg.unitX *= -1;              // put it in reverse
    bg.x += bg.unitX;                // translate because x doesn't move filter
    AT.tSVG.set(bg.astro, bg.x, FN.t);
}
function reverse(ez) {               // post() for k1, k2, o, v, bF, and FN.r
    idle();
}
function insignia(ez) {              // post() for hand, shirt
    idle();
}
function postK3(ez) {                // post() for k3
    idle();
}
////////////////////////////////////////////////////////////////////////////////
// the idle functions: idle() and startIdler()
function idle(isNow) {
    let i = Is.def(idler.idx) ? idler.idx++
                             : Math.floor(Math.random() * idler.eases.length);
    if (isNow)                       // isNow = once, on switch to random order
        startIdler(i);
    else {                           // interval = 10-20 seconds
        let dly = 1000 + Math.floor(Math.random() * 1001);
        setTimeout(startIdler, dly, i);
    }
}
function startIdler(i) {
    switch (i) {                     // some comments are for ordinal order only
    case  0:                         // astro translate + skewX
        RAF.eases.push(idler.eases.get(FN.t));
        RAF.eases.push(idler.eases.get(FN.skewX));
        break;
    case  1:                         // star brightness and whiteness
//        RAF.eases.push(idler.eases.get(AT.k1));
//        RAF.eases.push(idler.eases.get(AT.k3));
        idle();
        break;
    case  2:  case 10:  case 12:     // star quantity and more
//        RAF.eases.push(idler.eases.get(AT.k3));
        idle();
        break;
    case  3:  case  9:               // screen opacity
        RAF.eases.push(idler.eases.get(AT.o));
        break;
    case  4:  case 11:               // shift color matrix yellow <=> light blue
        RAF.eases.push(idler.eases.get(AT.v)); ///!!!adjust k3 for yellow versus blue???
        break;
    case  5:                         // revert to initial states
        RAF.eases.push(idler.eases.get(AT.k1));
        RAF.eases.push(idler.eases.get(AT.k3));
        break;
    case  6:                         // hand and armL together
        RAF.eases.push(idler.eases.get(hand));
        break;
    case  7:  case 14:               // if (bg[A.bF] == 1), filter looks empty
        RAF.eases.push(idler.eases.get(AT.bF));
        break;
    case  8:  case 13:               // rotate bg +/-360deg
        RAF.eases.push(idler.eases.get(FN.r));
        break;
    case 15:                         // shirt[A.bF] has no bummers
        RAF.eases.push(idler.eases.get(shirt));
        break;
    default:
//        idler.length = idler.idx;
//        delete idler.idx;
//        idle(true);                  // restart immediately in random order
//        return;
    }
    RAF.start();
}
</script>
</head>
<!--|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||-->
<body onload="loadIt()">
  <!--|||| svg defs |||||||||||||||||||||||||||||||||||||||||||||||||||||||||-->
  <svg xmlns="http://www.w3.org/2000/svg" height="0">
    <defs>
      <filter id="static">
        <feTurbulence              type="fractalNoise" baseFrequency="0.6,0.6" id="grain"/>
        <feColorMatrix result="r1" type="saturate" values="0" id="matrix"/>
        <feComposite   result="r2" in="SourceGraphic" in2="r1" k3="0.18" id="comp"
                                                      operator="arithmetic"/>
        <feBlend       result="r3" in="r2" in2="SourceGraphic"/>
        <feComposite operator="in" in="r3" in2="SourceGraphic"/>
      </filter>
      <filter id="astro">
        <feTurbulence type="fractalNoise" baseFrequency="1.5" seed="402" id="baseFrequency"></feTurbulence>
        <feColorMatrix result="r1" values="1 1 1 -1 0  1 1 -1 0 1  1 1 0 1 -1  1 1 1 1 1" id="values" type="matrix"></feColorMatrix>
        <feComposite   result="r2" in="SourceGraphic" in2="r1" operator="arithmetic" k3="9" id="k3"></feComposite>
        <feBlend       result="r3" in="r2" in2="SourceGraphic"></feBlend>
        <feComposite   result="r0" in="r3" in2="SourceGraphic" operator="in"></feComposite>

        <feColorMatrix result="r4" in="r0" type="luminanceToAlpha"></feColorMatrix>
        <feDiffuseLighting result="r5" surfaceScale="-10" diffuseConstant="0.5">
          <feDistantLight azimuth="225" elevation="20"></feDistantLight>
        </feDiffuseLighting>
        <feComposite   result="r6" in="r5" in2="r0" operator="arithmetic" k1="1" k2="1" k3="1" id="k2"></feComposite>
        <feBlend       result="r7" in="r4" in2="r6" mode="multiply"></feBlend>
        <feComposite   result="r8" in2="r7" k2="1.2"></feComposite>
        <feComposite   result="r9" in="r8" in2="r0" operator="in"></feComposite>

        <feColorMatrix result="r4" in="r9" type="luminanceToAlpha"></feColorMatrix>
        <feDiffuseLighting result="r5" surfaceScale="-10" diffuseConstant="0.75">
          <feDistantLight azimuth="225" elevation="20"></feDistantLight>
        </feDiffuseLighting>
        <feComposite   result="r6" in="r5" in2="r9" operator="arithmetic" k1="1" k2="0.4" k3="6" id="k1"></feComposite>
        <feBlend       result="r7" in="r4" in2="r6" mode="multiply"></feBlend>
        <feComposite   result="r8" in2="r7" operator="arithmetic" k2="1.3"></feComposite>
        <feComposite   result="r9" in="r8" in2="r9" operator="in"></feComposite>
      </filter>
      <filter id="cloth">
        <feTurbulence seed="399" type="fractalNoise" baseFrequency="10.797" id="weave"/>
        <feColorMatrix result="r1" type="saturate" values="0"/>
        <feComposite   result="r2" in="SourceGraphic" in2="r1" operator="arithmetic" k3="4"/>
        <feBlend       result="r3" in="r2" in2="SourceGraphic"/>
        <feComposite   result="r0" in="r3" in2="SourceGraphic" operator="in"/>
        <feColorMatrix result="r4" in="r0" type="luminanceToAlpha"/>
        <feDiffuseLighting result="r5" surfaceScale="-10" diffuseConstant="0.5">
          <feDistantLight azimuth="225" elevation="20"/>
        </feDiffuseLighting>
        <feComposite   result="r6" in="r5" in2="r0" operator="arithmetic" k1="1" k2="1" k3="1"/>
        <feBlend       result="r7" in="r4" in2="r6" mode="multiply"/>
        <feComposite   result="r8" in2="r7" operator="arithmetic" k2="1.2"/>
        <feComposite   result="r9" in="r8" in2="r0" operator="in"/>
        <feColorMatrix result="r4" in="r9" type="luminanceToAlpha"/>
        <feDiffuseLighting result="r5" surfaceScale="-10" diffuseConstant="0.5">
          <feDistantLight azimuth="225" elevation="20"/>
        </feDiffuseLighting>
        <feComposite   result="r6" in="r5" in2="r9" operator="arithmetic" k1="1" k2="1" k3="2"/>
        <feBlend       result="r7" in="r4" in2="r6" mode="multiply"/>
        <feComposite   result="r8" in2="r7" operator="arithmetic" k2="1.2"/>
        <feComposite   result="r9" in="r8" in2="r9" operator="in"/>
      </filter>
      <filter id="skin">
        <feTurbulence type="turbulence" baseFrequency="0.0165" seed="10"/>
        <feColorMatrix result="r1" type="saturate" values="0"/>
        <feComposite   result="r2" in="SourceGraphic" in2="r1" k3="4"
                                             operator="arithmetic"/>
        <feBlend       result="r3" in="r2" in2="SourceGraphic"/>
        <feComposite   result="r0" in="r3" in2="SourceGraphic" operator="in"/>
        <feColorMatrix result="r4" in="r0" type="luminanceToAlpha"/>
        <feDiffuseLighting result="r5" surfaceScale="-10" diffuseConstant="0.5">
          <feDistantLight azimuth="225" elevation="20"/>
        </feDiffuseLighting>
        <feComposite   result="r6" in="r5" in2="r0" operator="arithmetic" k1="1" k2="1" k3="1"/>
        <feBlend       result="r7" in="r4" in2="r6" mode="multiply"/>
        <feComposite   result="r8" in2="r7" operator="arithmetic" k2="1.2"/>
        <feComposite   result="r9" in="r8" in2="r0" operator="in"/>
        <feColorMatrix result="r4" in="r9" type="luminanceToAlpha"/>
        <feDiffuseLighting result="r5" surfaceScale="-10" diffuseConstant="0.5">
            <feDistantLight azimuth="225" elevation="20"/>
        </feDiffuseLighting>
        <feComposite   result="r6" in="r5" in2="r9" operator="arithmetic" k1="1" k2="1" k3="1.4"/>
        <feBlend       result="r7" in="r4" in2="r6" mode="multiply"/>
        <feComposite   result="r8" in2="r7" operator="arithmetic" k2="1.2"/>
        <feComposite   result="r9" in="r8" in2="r9" operator="in"/>
      </filter>
      <filter id="skiL">
        <feTurbulence type="turbulence" baseFrequency="0.0223" seed="10" id="baseFrequency0"/>
        <feColorMatrix result="r1" type="saturate" values="0"/>
        <feComposite   result="r2" in="SourceGraphic" in2="r1" k3="4"
                                             operator="arithmetic"/>
        <feBlend       result="r3" in="r2" in2="SourceGraphic"/>
        <feComposite   result="r0" in="r3" in2="SourceGraphic" operator="in"/>
        <feColorMatrix result="r4" in="r0" type="luminanceToAlpha"/>
        <feDiffuseLighting result="r5" surfaceScale="-10" diffuseConstant="0.5">
            <feDistantLight azimuth="225" elevation="20"/>
        </feDiffuseLighting>
        <feComposite   result="r6" in="r5" in2="r0" operator="arithmetic" k1="1" k2="1" k3="1"/>
        <feBlend       result="r7" in="r4" in2="r6" mode="multiply"/>
        <feComposite   result="r8" in2="r7" operator="arithmetic" k2="1.2"/>
        <feComposite   result="r9" in="r8" in2="r0" operator="in"/>
        <feColorMatrix result="r4" in="r9" type="luminanceToAlpha"/>
        <feDiffuseLighting result="r5" surfaceScale="-10" diffuseConstant="0.5">
            <feDistantLight azimuth="225" elevation="20"/>
        </feDiffuseLighting>
        <feComposite   result="r6" in="r5" in2="r9" operator="arithmetic" k1="1" k2="1" k3="1.4"/>
        <feBlend       result="r7" in="r4" in2="r6" mode="multiply"/>
        <feComposite   result="r8" in2="r7" operator="arithmetic" k2="1.2"/>
        <feComposite   result="r9" in="r8" in2="r9" operator="in"/>
      </filter>

      <filter id="spray" style="color-interpolation-filters:sRGB;"
               x="-1.5" y="-1" height="3" width="5">
        <feGaussianBlur    result="r1" stdDeviation="0.8"/>
        <feBlend           result="fbSourceGraphic" in2="r1" mode="multiply"/>
        <feTurbulence      result="r3" numOctaves="3" seed="0" type="fractalNoise" baseFrequency="5,1"/>
        <feDisplacementMap result="r2" in="fbSourceGraphic" in2="r3" scale="5" yChannelSelector="G" xChannelSelector="R"/>
        <feMorphology      result="r4" operator="dilate" radius="0.5"/>
        <feBlend           in2="r2"    mode="exclusion"/>
      </filter>

      <filter id="glow">
        <feGaussianBlur in="SourceGraphic" result="r1" stdDeviation="1.5"/>
        <feColorMatrix  in="SourceGraphic" result="r2"
                        values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 "/>
        <feComposite    operator="in" in="r1" in2="r2"/>
      </filter>

      <filter id="ring">
        <feGaussianBlur stdDeviation="5"/>
      </filter>
      <linearGradient id="c-shadow" x1="0" y1="0" x2="1" y2="1">
        <stop stop-color="#000000CC" offset="0.5"/>
        <stop stop-color="#000000CC" offset="1"/>
      </linearGradient>
      <filter id="shadow">
        <feGaussianBlur stdDeviation="6"/>
      </filter>
      <filter id="shape-dow">
        <feGaussianBlur stdDeviation="14"/>
      </filter>
      <filter id="armL-dow">
        <feGaussianBlur stdDeviation="3"/>
      </filter>
      <filter id="outer-dow">
        <feGaussianBlur stdDeviation="3"/>
      </filter>
      <filter id="inner-dow">
        <feGaussianBlur stdDeviation="0.5"/>
      </filter>
      <!--      <linearGradient id="c-hand" x1="0" y1="0" x2="1" y2="1">
            <stop stop-color="#000000DD" offset="0.5"/>
            <stop stop-color="#00000FDD" offset="1"/>
          </linearGradient>
          <filter id="hand-dow">
            <feGaussianBlur stdDeviation="3"/>
          </filter>
      -->

      <linearGradient id="wall" x1="0" y1="0" x2="1" y2="0.03">
        <stop stop-color="#0900008F" offset="0"   />
        <stop stop-color="#09000000" offset="0.28"/>
        <stop stop-color="#09000000" offset="0.78"/>
        <stop stop-color="#0900008F" offset="1"   />
      </linearGradient>
      <linearGradient id="bord" x1="0" y1="0" x2="1" y2="0">
        <stop stop-color="rgb(0,255,0)" offset="0  "/>
        <stop stop-color="rgb(0,204,0)" offset="0.5"/>
        <stop stop-color="rgb(0,255,0)" offset="1"  />
      </linearGradient>
      <linearGradient id="uline" x1="0" y1="0" x2="1" y2="0">
        <stop stop-color="#00FF00" offset="0"  />
        <stop stop-color="#00CC00" offset="0.5"/>
        <stop stop-color="#00FF00" offset="1"  />
      </linearGradient>
      <linearGradient id="lamp" x1="0" y1="0" x2="1" y2="1">
        <stop stop-color="#00FF00" offset="0"/>
        <stop stop-color="#000000" offset="1"/>
      </linearGradient>
      <linearGradient id="torso" x1="0" y1="0" x2="0" y2="1">
        <stop stop-color="#00EE00" offset="0"  />
        <stop stop-color="#00BB00" offset="0.5"/>
        <stop stop-color="#007700" offset="1"  />
      </linearGradient>
      <linearGradient id="share" x1="0" y1="0" x2="1" y2="0">
        <stop stop-color="#00AA00" offset="0"/>
        <stop stop-color="#00FF00" offset="1"/>
      </linearGradient>
      <linearGradient id="play" x1="0" y1="0" x="1" y2="0">
        <stop stop-color="#009900" offset="0"/>
        <stop stop-color="#00FF00" offset="1"/>
      </linearGradient>

      <linearGradient id="darkL" x1="0" y1="0" x2="1" y2="0">
        <stop stop-opacity="0" stop-color="#000000" offset="0"/>
        <stop stop-opacity="1" stop-color="#000000" offset="1"/>
      </linearGradient>
      <linearGradient id="darkR" x1="1" y1="0" x2="0" y2="0">
        <stop stop-opacity="0" stop-color="#000000" offset="0"/>
        <stop stop-opacity="1" stop-color="#000000" offset="1"/>
      </linearGradient>
      <linearGradient id="darkB" x1="0" y1="1" x2="0" y2="0">
        <stop stop-opacity="0" stop-color="#000000" offset="0"/>
        <stop stop-opacity="1" stop-color="#000000" offset="1"/>
      </linearGradient>

      <linearGradient id="fadeL" x1="0" y1="0" x2="1" y2="0">
        <stop stop-color="#FFFFFF00" offset="0"/>
        <stop stop-color="#FFFFFF00" offset="0"/>
        <stop stop-color="#FFFFFFFF" offset="0"/>
        <stop stop-color="#FFFFFFFF" offset="1"/>
      </linearGradient>
      <linearGradient id="fadeR" x1="0" y1="0" x2="1" y2="0">
        <stop stop-color="#FFFFFFFF" offset="0"/>
        <stop stop-color="#FFFFFFFF" offset="0"/>
        <stop stop-color="#FFFFFF00" offset="0"/>
        <stop stop-color="#FFFFFF00" offset="1"/>
      </linearGradient>
      <mask id="left">
        <rect x="19" y="3" width="394" height="205" fill="url(#fadeL)"/>
      </mask>
      <mask id="right">
        <rect x="19" y="3" width="394" height="205" fill="url(#fadeR)"/>
      </mask>

      <radialGradient id="rad">
        <stop stop-color="#0C0C0C" offset="0"/>
        <stop stop-color="#000000" offset="1"/>
      </radialGradient>
      <path id="shape" d="M 37,329
                          C  0,309   0, 39  37, 19
                          C 57,  1 375,  1 395, 19
                          C432, 39 432,309 395,329
                          C375,347  57,347  37,329"/>
      <path id="blur"  d="M 37,329
                          C  0,309   0, 39  37, 19
                          C 57,  1 375,  1 395, 19
                          C432, 39 432,309 395,329
                          C375,347  57,347  37,329
                          M  5,  1
                          L427,  1 427,347 5,347 Z"
            transform="scale(1.02 1.024) translate(-4.5 -3.75) skewX(-0.1) skewY(-0.1)"
            fill-rule="evenodd" fill="#00FF00" filter="url(#ring)"/>
      <clipPath id="clip">
        <use xlink:href="#shape"/>
      </clipPath>
      <mask id="mask">
        <rect width="474" height="380" fill="#FFFFFF" x="-15" y="-10"></rect>
        <use xlink:href="#shape" fill="#000000"/>
      </mask>
      <use id="scaled" xlink:href="#shape" x="10" y="10" transform="scale(0.975 0.975)"/>

      <!-- neck -->
      <linearGradient id="o-neck">
        <stop stop-opacity="0.45" offset="0.1"/>
        <stop stop-opacity="0.63" offset="0.2"/>
        <stop stop-opacity="0.5" offset="0.28"/>
        <stop stop-opacity="0.6" offset="0.4" />
        <stop stop-opacity="0.5" offset="0.9" />
      </linearGradient>
      <path id="neck" d="M163,326
                         L269,326
                 Q264,340 268,360
                 Q271,380 288,386
         L288,440 144,440 144,382
                 Q163,380 164,370
                 Q168,356 163,326 Z"/>
      <linearGradient id="mo-neck" x1="0" y1="0" x2="0" y2="1">
        <stop stop-color="#FFFFFF00" offset="0.18"></stop>
        <stop stop-color="#FFFFFF77" offset="0.25"></stop>
        <stop stop-color="#FFFFFFE0" offset="0.35"></stop>
      </linearGradient>
      <mask id="m-neck">
        <rect x="120" y="326" width="300" height="114" fill="url(#mo-neck)"/>
      </mask>

      <!-- right arm -->
      <linearGradient id="o-armR" x1="0" y1="0" x2="0.4" y2="1">
        <stop stop-opacity="0.8"  offset="0"/>
        <stop stop-opacity="0.6"  offset="0.07"/>
        <stop stop-opacity="0.55" offset="0.35"/>
        <stop stop-opacity="0.52" offset="0.55"/>
        <stop stop-opacity="0.48" offset="0.7" />
        <stop stop-opacity="0.55" offset="0.85"/>
        <stop stop-opacity="0.48" offset="0.99"/>
        <stop stop-opacity="0.44" offset="1"/>
      </linearGradient>
      <path id="armR" d="M 78,521
                         Q 88,575  76,615
                         Q 92,655 100,682
                 L100,685  39,685  39,682
                         Q 20,650  15,634
                         S -2,580   5,521 Z"/>

      <!-- left arm -->
      <linearGradient id="o-armL" x1="0.5" y1="0" x2="0" y2="1">
        <stop stop-opacity="0.53" offset="0"/>
        <stop stop-opacity="0.58" offset="0.35"/>
        <stop stop-opacity="0.53" offset="0.42"/>
        <stop stop-opacity="0.48" offset="0.55"/>
        <stop stop-opacity="0.53" offset="0.65"/>
        <stop stop-opacity="0.58" offset="0.71"/>
      </linearGradient>
      <path id="armL" d="M420,525
                         S438,584 417,646
                         Q405,674 365,672
                         S310,668 182,607
                         L182,569 204,569
                         S290,588 357,608
                         Q369,608 362,602
                         Q334,565 345,525 Z"/>
      <linearGradient id="mo-armL" x1="0" y1="0" x2="1" y2="0.04">
        <stop stop-color="#FFFFFF00" offset="0.59"></stop>
        <stop stop-color="#FFFFFFE0" offset="0.61"></stop>
      </linearGradient>
      <mask id="m-armL">
        <rect x="175" y="520" width="275" height="160" fill="url(#mo-armL)"/>
      </mask>

      <!-- left hand -->
      <radialGradient id="o-hand" cx="130" cy="565" r="60" gradientUnits="userSpaceOnUse">
        <stop stop-opacity="0.6"  offset="0.15"/>
        <stop stop-opacity="0.55" offset="0.25"/>
        <stop stop-opacity="0.55" offset="0.53"/>
        <stop stop-opacity="0.48" offset="1"/>
      </radialGradient>
      <path id="hand" d="M180,608
                         Q171,612 169,611
                         Q140,597 133,596
                         Q128,596 125,602
                         Q115,606 119,604
                 C110,601  96,578 107,571
                                 L110,571
                         Q124,571 121,548
                                 L122,544
                         Q127,532 140,525
                         Q152,474 165,516
                 C175,543 187,550 195,555
                         S199,566 204,569
                         Q206,592 189,604 Z"/>

      <!-- left pinky -->
      <linearGradient id="c-pinky" x1="0" y1="0.4" x2="1" y2="0">
        <stop stop-color="#00001AFF" offset="0"/>
        <stop stop-color="#00001AFF" offset="0.35"/>
        <stop stop-color="#00001AFF" offset="0.5" />
        <stop stop-color="#00001A00" offset="0.75"/>
      </linearGradient>
      <linearGradient id="o-pinky" x1="0" y1="0.4" x2="1" y2="0">
        <stop stop-opacity="0.45" offset="0.17"/>
        <stop stop-opacity="0.5"  offset="0.32"/>
        <stop stop-opacity="0.5"  offset="0.6" />
        <stop stop-opacity="0"    offset="0.9" />
      </linearGradient>
      <path id="pinky" d="M133,595
                          Q128,596 126,601
                          S115,606 115,603
                  C109,601  95,578 107,571
                          Q117,567 122,566
                          Q133,586 133,595"/>

      <!-- shirt -->
      <path id="shirt" d="M288,386
                  C324,390 372,396 400,411
                          Q436,428 420,526
                                  L345,526
                          S343,485 338,511
                          Q327,594 328,682
                                  L102,682
                          Q 99,626  90,559
                          S 79,452  78,522
                                  L  5,522
                          Q -6,428  32,405
                  C 60,390 108,385 144,382
                          Q210,446 288,386"/>
      <clipPath id="p-shirt">
        <use xlink:href="#shirt"/>
      </clipPath>
      <radialGradient id="insignia">
        <stop stop-color="#170C06" stop-opacity="0.961" offset="0.68" id="stop-opacity"/>
        <stop stop-color="#170C06" stop-opacity="0" offset="1"/>
      </radialGradient>

      <!-- full body clipping for the transporter beam -->
      <clipPath id="p-body">
        <use xlink:href="#shape"/>
        <use xlink:href="#neck" />
        <use xlink:href="#armL" />
        <use xlink:href="#armR" />
        <use xlink:href="#shirt"/>
      </clipPath>

      <!-- mute button -->
      <linearGradient id="gradBase" x1="0" y1="1" x2="1" y2="0">
        <stop stop-color="#009900" offset="0"/>
        <stop stop-color="#00BB00" offset="1"/>
      </linearGradient>
      <linearGradient id="gradCone" x1="0" y1="0" x2="1" y2="1">
        <stop stop-color="#00CC00" offset="0"/>
        <stop stop-color="#00EE00" offset="0.9"/>
      </linearGradient>
      <linearGradient id="gradX" x1="0" y1="1" x2="1" y2="0">
        <stop stop-color="#669966" offset="0"/>
        <stop stop-color="#99BB99" offset="1"/>
      </linearGradient>
      <path id="base" d="M 3,7 L  7, 7     7,17     3,17 Z
                         M 8,7 L 17, 1    17,23     8,17 Z"/>
      <path id="cone" d="M17,8 C 21,10.67 21,13.33 17,16 Z"/>
      <g id="No">
        <use xlink:href="#base" fill="url(#gradBase)" filter="url(#mute-glo)"/>
        <use xlink:href="#cone" fill="url(#gradCone)" filter="url(#mute-glo)"/>
      </g>
      <g id="Hi">
        <!-- muted -->
        <use xlink:href="#base" fill="url(#gradX)" filter="url(#mute-glo)"/>
        <path stroke="#336633" fill="none" filter="url(#mute-glo)"
              stroke-width="2" d="M 14,9 L 20,15 M 20,9 L 14,15"/>
      </g>

      <!-- smiley face for welcome animation -->
      <g id="smiley">
        <path d="M 0,16 C 0,1 18,1 18,16 C 18,31.5 0,31.5 0,16 z
                 M 2.5,16 C 2.5,4.5 15.5,4.5 15.5,16 C 15.5,28 2.5,28 2.5,16 z"
              filter="url(#smiley-glo)" fill-rule="evenodd"/>
        <ellipse filter="url(#smiley-glo)" cx="6"  cy="13.5" rx="2" ry="3"/>
        <ellipse filter="url(#smiley-glo)" cx="12" cy="13.5" rx="2" ry="3"/>
        <path filter="url(#smiley-glo)" d="M 4,18.5 L14,18.5 S 9,28.5 4,18.5 Z"/>
      </g>

      <!-- rainbow gradient for welcome text -->
      <linearGradient id="rainbow">
        <stop stop-color="#FF0000" offset="0"/>
        <stop stop-color="#FFFF00" offset="0.04"/>
        <stop stop-color="#FFFFFF" offset="0.08"/>
        <stop stop-color="#00FFFF" offset="0.12"/>
        <stop stop-color="#0000FF" offset="0.16"/>
        <stop stop-color="#FF00FF" offset="0.2" />
        <stop stop-color="#FFFFFF" offset="0.24"/>

        <stop stop-color="#FF0000" offset="0.28"/>
        <stop stop-color="#FFFF00" offset="0.32"/>
        <stop stop-color="#FFFFFF" offset="0.36"/>
        <stop stop-color="#00FFFF" offset="0.4" />
        <stop stop-color="#0000FF" offset="0.44"/>
        <stop stop-color="#FF00FF" offset="0.48"/>
        <stop stop-color="#FFFFFF" offset="0.52"/>

        <stop stop-color="#FF0000" offset="0.56"/>
        <stop stop-color="#FFFF00" offset="0.6" />
        <stop stop-color="#FFFFFF" offset="0.64"/>
        <stop stop-color="#00FFFF" offset="0.68"/>
        <stop stop-color="#0000FF" offset="0.72"/>
        <stop stop-color="#FF00FF" offset="0.76"/>
        <stop stop-color="#FFFFFF" offset="0.8" />

        <stop stop-color="#FF0000" offset="0.84"/>
        <stop stop-color="#FFFF00" offset="0.88"/>
        <stop stop-color="#FFFFFF" offset="0.92"/>
        <stop stop-color="#00FFFF" offset="0.96"/>
        <stop stop-color="#0000FF" offset="1"/>
      </linearGradient>
    </defs>
  </svg> <!--end svg defs |||||||||||||||||||||||||||||||||||||||||||||||||||-->
  <!--|||| svg background |||||||||||||||||||||||||||||||||||||||||||||||||||-->
  <svg id="bg" preserveAspectRatio="xMidYMid slice" xmlns="http://www.w3.org/2000/svg">
      <rect opacity="0" filter="url(#static)" fill="url(#rad)"/>
      <rect opacity="0" filter="url(#astro)"/>
      <rect opacity="0"   fill="url(#wall)"/>
  </svg>
  <!--|||| svg typist wrapped in a flex <div> |||||||||||||||||||||||||||||||-->
  <div style="position:absolute; display:flex; flex-flow:row nowrap; justify-content:flex-end;">
      <svg id="typist" viewBox="14 3 422.25 205" preserveAspectRatio="xMinYMin slice" opacity="0"
           xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <text style="mask:url(#left);"></text> <!-- typist.text   -->
          <text x="37.75" y="32">_</text>        <!-- typist.cursor -->
          <text x="19" y="32">&gt;</text>        <!-- typist.prompt -->
          <g style="opacity:0;">
              <g>
                  <!-- top  smileys -->
                  <use x= "19.25" y="5" xlink:href="#smiley" transform="rotate(0  28 32)" fill="#FF0000"/>
                  <use x="413"    y="5" xlink:href="#smiley" transform="rotate(0 422 32)" fill="#FF0000"/>
              </g>
              <g>
                  <!-- mid smileys -->
                  <use x= "19.25" y="37" xlink:href="#smiley" transform="rotate(0  28 64)" fill="#FFFFFF"/>
                  <use x="413"    y="37" xlink:href="#smiley" transform="rotate(0 422 64)" fill="#FFFFFF"/>
              </g>                                           <!-- rainbow chars -->
              <g>
                  <!-- bottom smileys -->
                  <use x= "19.25" y="69" xlink:href="#smiley" transform="rotate(0  28 96)" fill="#0000FF"/>
                  <use x="413"    y="69" xlink:href="#smiley" transform="rotate(0 422 96)" fill="#0000FF"/>
              </g>
              <!-- rainbow chars -->
              <text class="rainbow" style="font-family:DejaVuSans;">
                  <tspan x="168" y="32" style="font-size:30px;">&#x2640;</tspan>
                  <tspan x="189" y="32" style="font-size:30px;">&#x262E;</tspan>
                  <tspan x="215" y="32" style="font-size:30px;">&#x2642;</tspan>

                  <tspan x="294" y="32" style="font-size:32px;">&#x2601;</tspan>
                  <tspan x="241" y="32" style="font-size:28px;">&#x2665;</tspan>
                  <tspan x="266" y="33" style="font-size:32px;">&#x2620;</tspan>

                  <tspan x="368" y="32" style="font-size:30px;">&#x266B;</tspan>
                  <tspan x="355" y="39" style="font-size:32px;" rotate="-30">&#x263E;</tspan>
                  <tspan x="329" y="32" style="font-size:30px;">&#x266A;</tspan>
              </text>
              <!-- rainbow welcome text -->
              <text x="56.5" y="3em" class="rainbow">welcOme tO my sIte</text>
              <!-- 4 asterisks -->
              <g>
                  <text x="150.25" y="1.19em" transform="rotate(0 159.35 24.4)" style="fill:#0000FF;">*</text>
                  <text x="394" y="1.19em" transform="rotate(0 403.1  24.4)" style="fill:#0000FF;">*</text>
              </g>
          </g>
          <text x="37.75" y="3.19em" transform="rotate(0  46.85 88.4)" style="visibility:hidden;">*</text>
          <text x="394" y="3.19em" transform="rotate(0 403.1  88.4)" style="visibility:hidden;">*</text>

          <g>
              <!-- YES NO -->
              <text x="131.5" y="192" style="filter:url(#yes-glo); visibility:hidden;">YES&gt;</text>
              <rect x="131"   y="169" width="75" height="30" class="none" id="yes"/>
              <rect x="133.5" y="195" width="0" height="3" ry="2" rx="2"
                                      fill="url(#uline)" filter="url(#yes-glo)"/>
              <text x="244"   y="192" style="filter:url(#no-glo);  visibility:hidden;">NO&gt;</text>
              <rect x="242"   y="169" width="58" height="30" class="none" id="no"/>
              <rect x="244"   y="195" width="0" height="3" ry="2" rx="2"
                                      fill="url(#uline)" filter="url(#no-glo)"/>
          </g>
      </svg>
  </div>
  <!--|||| main |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||-->
  <main id="main" style="overflow:hidden; pointer-events:none;">
    <!--|||| svg logo and creature ||||||||||||||||||||||||||||||||||||||||||-->
    <svg width="0" style="max-height:100%; max-width:100%; align-self:flex-start;"
         id="svg" viewBox="14 3 404 205" preserveAspectRatio="xMinYMin slice"
         xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
      <g id="dark" style="opacity:0.3; visibility:hidden;">
          <!-- part of wiper animation -->
          <g>
              <rect x="24" y=  "3" width="384" height="198"/>
              <path d="M 14,  3 L 24,  3  24,198  14,208 Z" fill="url(#darkL)"/>
              <path d="M418,  3 L408,  3 408,198 418,208 Z" fill="url(#darkR)"/>
              <path d="M 14,208 L 24,198 408,198 418,208 Z" fill="url(#darkB)"/>
          </g>
          <g>
              <rect x="14" y=  "3" width="404" height="191"/>
              <rect x="14" y="194" width="404" height= "14" fill="url(#darkB)"/>
          </g>
      </g>

      <g id="body" opacity="0">
          <!-- the waist-up body elements-->
          <use xlink:href="#scaled" fill="url(#c-shadow)" filter="url(#shape-dow)"
                                                            mask="url(#mask)"/>

          <use xlink:href="#neck"    fill="url(#c-shadow)" filter="url(#shadow)"   x="2" y="3"
                                                             mask="url(#m-neck)"/>
          <use xlink:href="#neck"    fill="#00001A"        filter="url(#glow)"/>
          <use xlink:href="#neck"    fill="url(#o-neck)"   filter="url(#skin)"/>

          <use xlink:href="#shape"   fill="url(#rad)" id="opacity"/>
          <use xlink:href="#shape"   style="opacity:0;"     filter="url(#static)" id="shapeStatic"/>
          <use xlink:href="#blur"    clip-path="url(#clip)"/>

          <use xlink:href="#shirt"   fill="url(#c-shadow)" filter="url(#shadow)"   x="1" y="4"/>
          <use xlink:href="#shirt"                         filter="url(#cloth)"/>

          <use xlink:href="#armR"    fill="url(#c-shadow)" filter="url(#shadow)"   x="4" y="0"
                         transform="scale(0.95 1)"/>
          <use xlink:href="#armR"    fill="#00001A"/>
          <use xlink:href="#armR"    fill="url(#o-armR)"   filter="url(#skin)"/>

          <use xlink:href="#armL"    fill="url(#c-shadow)" filter="url(#armL-dow)" x="1" y="1"
               mask="url(#m-armL)"/>
          <use xlink:href="#armL"    fill="#00001A"/>
          <use xlink:href="#armL"    fill="url(#o-armL)"   filter="url(#skiL)"/>

          <g id="g-hand" transform="rotate(0 180 585)">
            <use xlink:href="#hand"  fill="#00001A"/>
            <use xlink:href="#hand"  fill="url(#o-hand)"   filter="url(#skin)"/>
            <use xlink:href="#pinky" fill="url(#c-pinky)"/>
            <use xlink:href="#pinky" fill="url(#o-pinky)"  filter="url(#skin)"/>
          </g>

          <path fill="#170C06F7" filter="url(#glow)"
                d="M147,381 L133,382 S205,480 300,386 L286,384 Q210,441 147,381"/>
          <path fill="#170C06F9" filter="url(#glow)"
                d="M342,514 L344.5,527 422,527 423,514 Z"/>
          <path fill="#170C06F9" filter="url(#glow)"
                d="M2.5,510 L3.5,523 79,523 80,510 Z"/>

          <circle cx="286"  cy="504.7" fill="url(#insignia)" r="20"/>
          <text    x="278.7" y="504.7" style="fill:#FFA500; filter:url(#s-glo);"
                  id="s"     transform="rotate(90 278.5 504.9)"
                  text-anchor="middle">s</text>
      </g>

      <!-- If there is whitespace between the tspans, x gets funky -->
      <text id="logo" style="mask:url(#right);"><tspan>In      _&nbsp;_</tspan><tspan> One    &lt;+&nbsp;+&gt;</tspan><tspan>   eaR&nbsp;&gt;&gt;&nbsp;^&nbsp;&lt;&lt;&nbsp;Out</tspan><tspan>         (=)     the</tspan><tspan>          ~     OtheR</tspan><tspan>&gt;sIdeways&nbsp;skullfIngeR</tspan></text>
      <text id="prompt" x="17.75" y="32" style="visibility:hidden;">&gt;</text>
      <rect id="border" x="19" y="201" fill="url(#bord)" filter="url(#glow)"
            width="394" height="3" ry="2" rx="2" opacity="0"/>

      <g id="controls">
        <!-- spelunker, links, menus, mute button -->
        <g>
          <!-- spelunker button, song title, drop-down button -->
          <g transform="translate(28.5)">
            <!-- separate transform for scripting -->
            <g transform="translate(0    208.3) scale(0.24 0.24)">
              <g transform="translate(0 6)" fill="#00FF00" class="spelunk">
                <path d="M80.383,24.582c0,4.586-3.711,8.297-8.273,8.297c-2.805,0-5.297-1.414-6.781-3.539h2.609c1.727,0,3.242-1.023,3.945-2.492l1.125-2.414c0.078-0.148,0.219-0.266,0.414-0.266h6.961V24.582z"/>
                <path d="M81.969,22.043c-1.125-4.398-5.125-7.641-9.859-7.641c-5.633,0-10.18,4.562-10.18,10.18c0,0.93,0.125,1.828,0.344,2.656h5.664c0.906,0,1.703-0.531,2.07-1.289l1.094-2.422c0.391-0.875,1.297-1.484,2.32-1.484H81.969z"/>
              </g>
              <path transform="translate(0 6)" fill="url(#lamp)" class="spelunk" d="M85.117,22.137c-0.367-0.336-0.609-0.852-0.609-1.391c0-1.07,0.859-1.93,1.906-1.93l28.664,0.023c2.898,0.031,4.688,8.234,2.734,14.68c-1.836,5.977-7.281,13.695-9.844,11.078L85.117,22.137z"/>
              <g fill="url(#torso)">
                <path class="spelunk" transform="translate(-2 5)" d="M52.656,29.418c1.023-0.836,1.172-2.32,0.344-3.32l-4.469-5.5c-0.836-1.023-2.32-1.172-3.32-0.336L26.102,35.785c-1,0.828-1.172,2.32-0.336,3.344l4.461,5.492c0.836,1.008,2.32,1.148,3.352,0.344L52.656,29.418z"/>
                <path class="spelunk" d="M33.797,51.387c-1.078,0.828-2.008,1.883-2.711,3.125c-0.688,1.195-1.102,2.469-1.297,3.734l-5.445,23.461L9.328,96.16c-0.414,0.391-0.781,0.836-1.047,1.344c-1.586,2.758-0.633,6.273,2.148,7.859c2.219,1.273,4.953,0.883,6.742-0.75l16.695-16.141c0.242-0.297,0.461-0.609,0.656-0.953c0.25-0.438,0.445-0.875,0.562-1.344l3.398-14.867l11.164,11.133l-0.023,18.773c0,2,1.055,3.93,2.906,5.008c2.758,1.562,6.273,0.609,7.859-2.148c0.539-1,0.781-2.055,0.734-3.102l0.023-20.875c0.055-1.492-0.484-2.953-1.508-4.078L47.602,64.129l13.844-11.352l3.195,8.867c0.273,0.586,0.688,1.117,1.195,1.531l13.227,10.039c1.781,1.094,4.18,0.805,5.664-0.781c1.711-1.836,1.609-4.711-0.219-6.422c-0.047-0.047-0.125-0.102-0.172-0.148l-11.594-8.859l-5.367-15.75c-0.852-2.07-2.367-3.883-4.469-5.078c-3.562-2.023-7.836-1.734-11.008,0.414L33.797,51.387z"/>
              </g>
              <rect id="spelunk" class="none" width="133.33" height="133.33"/>
            </g>
          </g>
          <text id="song" x="59.8" y="234"></text>
          <g fill="#00FF00">
            <!-- drop-down <select>-ish button -->
            <path filter="url(#songButt-glo)" fill-rule="evenodd"
                  d="M61,216 S61,213 64,213
                     L80,213 S83,213 83,216
                     L83,234 S83,237 80,237
                     L64,237 S61,237 61,234 Z
                     M64,217 S64,216 65,216
                     L79,216 S80,216 80,217
                     L80,233 S80,234 79,234
                     L65,234 S64,234 64,233 Z"/>
            <path d="M68,221 L72,229 76,221" filter="url(#songButt-glo)" transform="rotate(0 72 224.5)"/>
            <rect x="56" y="209" width="32" height="32" id="songButt" class="none"/>
          </g>
        </g>

        <g text-anchor="middle">
          <!-- four hyperlinks -->
          <g>
            <text x="215.6" y="270" class="link" style="filter:url(#faq-glo);">FAQ            </text>
            <rect x="75" y="272" width="56.25" height="3" ry="2" rx="2"
                  fill="url(#uline)" filter="url(#faq-glo)"/>
            <rect x="86" y="248" width="54" height="29" id="faq" class="none"/>
          </g>
          <g>
            <text x="215.6" y="270" class="link" style="filter:url(#fuq-glo);">FUQ    </text>
            <rect x="150" y="272" width="56.25" height="3" ry="2" rx="2"
                  fill="url(#uline)" filter="url(#fuq-glo)"/>
            <rect x="155" y="248" width="54" height="29" id="fuq" class="none"/>
          </g>
          <g>
            <text x="215.6" y="270" class="link" style="filter:url(#bio-glo);">    bIO</text>
            <rect x="225" y="272" width="56.25" height="3" ry="2" rx="2"
                  fill="url(#uline)" filter="url(#bio-glo)"/>
            <rect x="223" y="248" width="54" height="29" id="bio" class="none"/>
          </g>
          <g>
            <text x="215.6" y="270" class="link" style="filter:url(#smaws-glo);">              smaws</text>
            <rect x="300" y="272" width="93.75" height="3" ry="2" rx="2"
                  fill="url(#uline)" filter="url(#smaws-glo)"/>
            <rect x="291" y="248" width="87" height="29" id="smaws" class="none"/>
          </g>
        </g>

        <g>
          <!-- three buttons -->
          <g transform="translate(157 284)">
            <rect width="32" height="32" id="shareButt" class="none"/>
            <g transform="translate(3 3) scale(1.1 1.1)"
               fill="url(#share)" filter="url(#shareButt-glo)">
              <path d="M 3,11 L 21, 2.5 21, 4.5 5,12
                        21,19.5 21,21.5  3,13 Z" fill="url(#uline)"/>
              <circle cx= "3" cy="12"   r="3.33"/>
              <circle cx="21" cy= "3.5" r="3.33"/>
              <circle cx="21" cy="20.5" r="3.33"/>
            </g>
          </g>
          <g transform="translate(200.5 283)">
            <rect width="31" height="32" id="downButt" class="none"/>
            <g fill="#00FF00" filter="url(#downButt-glo)">
              <path d="M 1,25
                       L 1,29 S 1  ,31    3,31
                       L28,31 S30  ,31   30,29
                       L30,25 S28.5,23.5 27,25
                       L27,28 4,28 4,25
                       S 2.5,23.5  1,25"/>
              <path d="M14, 4
                       L14,21 9.25,16.25 S6.63,15.75 7.13,18.37
                       L13.88,25.12 S15.5 ,26.5  17.12,25.12
                       L23.87,18.37 S24.37,15.75 21.75,16.25
                       L17,21 17,4 S15.5,3 14,4"/>
            </g>
          </g>
          <g transform="translate(244 284)">
            <rect width="32" height="32" id="streamButt" class="none"/>
            <path fill="url(#play)" filter="url(#streamButt-glo)"
                  d="M 4,4 L 28,16 4,28 Z"/>
          </g>
        </g>

        <!-- mute button -->
        <g transform="scale(0.9 0.9) translate(40.85, 338) rotate(-41 12 12)">
          <use xlink:href="#No"/>
          <rect id="mute" class="none" width="24" height="24"/>
        </g>

        <g id="songMenu" opacity="0">
          <!-- must be on top, thus last in group -->
          <rect x="45.809375" y="198" width="338.78125" filter="url(#outer-dow)"
                rx="6" ry="6" fill="#0A0A0A" pointer-events="visible"/>
          <rect x="52.809375" y="205" width="324.78125" filter="url(#inner-dow)"
                rx="3" ry="3" fill="none" pointer-events="visible"
                stroke-width="2" stroke="#00AA00"/>
          <g>
            <!-- the list of songs, each a <g> -->
            <g style="visibility:hidden;">
              <!-- this gets cloned in loadIt() -->
              <rect x="57.809375" y="209" width="314.78125" class="none"/>
              <text x="59.809375" y="234" class="song"></text>
            </g>
          </g>
        </g>
      </g> <!-- end controls wrapper -->

      <rect id="transporter" clip-path="url(#p-body)" filter="url(#static)"
            width="444" height="692" style="opacity:0;"/>
    </svg>
    <!--|||| svg wiper ||||||||||||||||||||||||||||||||||||||||||||||||||||||-->
    <svg viewBox="14 3 404 205" style="position:absolute" xmlns="http://www.w3.org/2000/svg">
      <rect id="wipe" y="7" width="1.5" height="200"
         style="visibility:hidden; fill:#00FF00; filter:url(#spray);"/>
    </svg>

    <!--|||| post-agree menus |||||||||||||||||||||||||||||||||||||||||||||||-->
    <div id="shareMenu"  style="position:absolute; opacity:0; width:153px; min-height:191px;"></div>
    <div id="downMenu"   style="position:absolute; opacity:0;"></div>
    <div id="streamMenu" style="position:absolute; opacity:0;"></div>
    <svg id="beam" style="position:absolute; opacity:0" xmlns="http://www.w3.org/2000/svg">
      <rect filter="url(#static)" rx="8" ry="8"/>
    </svg>

    <!--|||| pre-agree div and agree button(s) ||||||||||||||||||||||||||||||-->
    <div id="terms" style="display:none;">
      <!--      <p style="margin:0 0 12px 0;">
                This site contains dirty language and lewd images. If such things
                offend you, please visit:
                <a href="http://sidewaysskullfinger.com" class="a">SidewaysSkullfinger.com</a>
            </p>
      -->
      <p>
        <i>
          By clicking "I agree" you are confirming that you understand and
          agree to these terms and conditions:
        </i>
      </p>
      <p class="agree">
          1. The contents of this website are copyrighted by me,
          except where otherwise noted. Any use of this
          copyrighted material without my explicit permission
          is prohibited.
      </p>
      <p class="agree">
          2. This website is entirely fictitious. Any similarity
          to actual objects or persons, living or dead, is
          purely coincidental.
      </p>
      <p class="agree">
          3. This website collects no personal data, thus it has
          no privacy policy.
      </p>
      <div style="display:flex; flex-flow:row nowrap; justify-content:center;">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 143 41" height="82" style="margin:12px;">
          <rect width="143" height="41" id="agree" class="none"/>
          <path filter="url(#agree-glo)" fill="#FFFFFF" fill-rule="evenodd"
                d="M  0, 3 S  0, 0   3, 0
                   L140, 0 S143, 0 143, 3
                   L143,38 S143,41 140,41
                   L  3,41 S  0,41   0,38 Z
                   M  3, 4 S  3, 3   4, 3
                   L139, 3 S140, 3 140, 4
                   L140,37 S140,38 139,38
                   L  4,38 S  3,38   3,37 Z"/>
          <text style="fill:#FFFFFF; filter:url(#agree-glo);"
                x="9" y="31">I<tspan x="38">agree</tspan></text>
        </svg>
      </div>
    </div>
  </main>
</body>
</html>
